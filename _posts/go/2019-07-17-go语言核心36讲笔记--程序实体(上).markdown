##### 第四讲：程序实体的那些事儿（上）

---

之前的章节，文章展示了“程序从初建到拆分，再到模块化”的基本过程。这个过程基本上所有语言都是通用的，所以现在来点不一样的事儿、

特性：我们知道Go是静态类型的语言，所以变量声明的时候要指定它的类型，就像这样`var name string` 忽略语法的怪异性，其实和其他语言没什么差别。只不过变量的类型还可以是函数或者是结构体或者是接口等我们自定义的一些实体，这点和Js很像。

##### 不多说了，我们回到文章的问题上：声明变量有几种方式？

简单的挑两种出来：1.`var name string` 2.`var name = flag.String(...)`，一种是直接定义类型，另一种是通过函数来确定类型。要知道flag.String()返回的是*string——指针，不是单纯的string类型（好久没碰指针了，没想到学go还要再见到它，真的是欲哭无泪）关于指针在后续的文章中有说到。

上面的两种方式实际上可以归类为一种，通过var来确定是一个变量，然后再确定类型。接下来的第二种是go比较独特的东西，**短变量声明**

```go
name := flag.String(...);
```



这个问题的知识点是：**Go语言的类型推断**，以及**短变量声明**。类型推断是指用函数赋值的时候，我们并没有显示的制定name的数据类型，只是通过flag.String()返回的东西知道它是string的指针。这就是Go语言的类型推断。

而短变量声明实际上是一个语法糖，它有使用的限制

- 只能在方法体内使用短变量声明

话说回来，类型推断看上去挺牛逼的，可看上去并没有什么好处啊，不过是写法不同而已，为什么要做这样一个特性呢？

**答案是它可以更加灵活的用于代码重构** ，听到重构这一个词是不是想到了很经典的一本书？接下来展示一下，它是如何让重构更加轻松的，我们将name赋值为我们自定义的函数

```go
package main

import (
	"flag"
	"fmt"
)

func getTheFlag()*string{
	return flag.String("name","everyone","the greeting object.")
}

func main()  {
	var name=getTheFlag()
	flag.Parse()
	fmt.Printf("Hello,%s\n",*name)
}
```

这样我们更改`getTheFlag()`里的内容，使其返回的依然是*string的结果，就不会妨碍其他代码的运行，这种只需要内部变化的修改叫做重构、

实际上如果是采用之前的赋值方法，直接修改name的赋值可能也很容易，但是在它之前如果要加逻辑来运算得出结果进行赋值，会让代码看上去很臃肿。实际上类型推导在赋值过程中多加了一层，使得它们之间的耦合变得宽松，可以把逻辑和运算放在方法中，重构自然就更加灵活和容易。

这种动态获得数据类型的特性实际上在Js，python这样的动态类型语言中很常见，但是它们是以牺牲性能为代价来获取这种遍历，而go不一样，go是在编译期间确定的数据类型，所以兼顾灵活和高效。



##### 敲黑板啦，又有一个知识点汹涌来袭：变量重声明

通过使用**短变量声明**我们可以对同一个代码块中的变量进行重新声明。代码块的定义是一对花括号括起来的区域。*Go语言本身和我们编写的代码共同形成了一个非常大的代码块——全域代码块。这就像Js中的全局变量一样，无论在哪个js文件中都可以直接访问，Go中只要是公开的全局变量，也是一样的可以被任何代码访问。*

变量重新声明的限制

- 重新声明的变量类型要与初次声明的类型相同
- 变量的重声明只能发生在某个代码块中。如果与外层变量重名，是覆盖
- 变量的重声明只有使用短变量声明的时候才有用
- 重声明并赋值的变量必须是多个，而且至少一个新变量。这样才能说是对旧变量的重新声明

用一个例子说明一下变量重声明带来的好处

```go
// io包中的方法
func WriteString(w Writer, s string) (n int, err error) {
	if sw, ok := w.(StringWriter); ok {
		return sw.WriteString(s)
	}
	return w.Write([]byte(s))
}
//......................
// 变量重声明，
var err error
//...期间使用err变量干了些事情，然后需要对它赋值，假设没有变量重声明
n,err2 := io.WriteString(os.Stdout,"Hello everyone!\n")
err=err2
//它多了两个步骤，第一 声明一个err2变量，第二 将err2的值赋给err
//实际上只需要，
n,err := io.WriteString(...)
```

实际上，从上面的例子中并不能完全体会变量重声明的好处，它实际上是一个语法糖。**它允许我们在使用短变量声明的时候不用理会被赋值的多个变量中是否包含已经声明过的变量。**它和Java并发的可重入锁有些类似。



思考题：

##### 如果与当前的变量重名的是外层代码块中的变量，意味着什么？

从我写java的经验来说，是覆盖。

```go
var n float64
func getTheFlag() *string {
	fmt.Println(n)
	var err error
	n,err:=io.WriteString(os.Stdout,"hello world")
	fmt.Println()
	fmt.Println(n,err)
	return flag.String("name", "everyone", "the greeting object.")
}
```

按理说n是float64类型的，但是在getTheFlag()中声明为int却没有报错，很明显是发生了覆盖。









