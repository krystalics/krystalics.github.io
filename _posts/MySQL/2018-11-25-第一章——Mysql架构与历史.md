<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第一章：MySQL架构与历史](#%E7%AC%AC%E4%B8%80%E7%AB%A0mysql%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2)
  - [1.1 MySQL 逻辑架构](#11-mysql-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84)
    - [1.1.1 连接管理与安全性](#111-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7)
    - [1.1.2 优化与执行](#112-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C)
  - [1.2 并发控制](#12-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
    - [1.2.1 读写锁](#121-%E8%AF%BB%E5%86%99%E9%94%81)
    - [1.2.2 锁粒度](#122-%E9%94%81%E7%B2%92%E5%BA%A6)
  - [1.3 事务](#13-%E4%BA%8B%E5%8A%A1)
    - [1.3.1 隔离级别](#131-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
    - [1.3.2 死锁](#132-%E6%AD%BB%E9%94%81)
    - [1.3.3 事务日志](#133-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97)
    - [1.3.4 MySQL中的事务](#134-mysql%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1)
  - [1.4 多版本并发控制（MVCC）](#14-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc)
  - [1.5 MySQL的存储引擎](#15-mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
    - [1.5.1 选择适合的存储引擎](#151-%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
    - [**日志型应用**](#%E6%97%A5%E5%BF%97%E5%9E%8B%E5%BA%94%E7%94%A8)
    - [**在只读或者大部分情况下只读的表**：](#%E5%9C%A8%E5%8F%AA%E8%AF%BB%E6%88%96%E8%80%85%E5%A4%A7%E9%83%A8%E5%88%86%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AA%E8%AF%BB%E7%9A%84%E8%A1%A8)
    - [订单处理](#%E8%AE%A2%E5%8D%95%E5%A4%84%E7%90%86)
    - [电子公告牌和主题讨论论坛](#%E7%94%B5%E5%AD%90%E5%85%AC%E5%91%8A%E7%89%8C%E5%92%8C%E4%B8%BB%E9%A2%98%E8%AE%A8%E8%AE%BA%E8%AE%BA%E5%9D%9B)
    - [大数据量](#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F)
    - [转换表的存储引擎](#%E8%BD%AC%E6%8D%A2%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
    - [导入和导出](#%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA)
    - [创建于查询(create 和 select)](#%E5%88%9B%E5%BB%BA%E4%BA%8E%E6%9F%A5%E8%AF%A2create-%E5%92%8C-select)
  - [1.6 MySQL时间线(TimeLine)](#16-mysql%E6%97%B6%E9%97%B4%E7%BA%BFtimeline)
  - [1.7 MySQL的开发模式](#17-mysql%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)
  - [1.8 总结](#18-%E6%80%BB%E7%BB%93)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

*《高性能MySQL 第三版》O'Reilly Media Inc.*

### 第一章：MySQL架构与历史

---

#### 1.1 MySQL 逻辑架构

​	如果能在头脑中构建出一幅MySQL各组件之间如何协同工作的架构图，就会有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。

![](https://github.com/MrAlan/MyPostPicture/blob/master/36.png?raw=true)

​	最上层的服务并不是MySQL独有的，大多数基于网络的C/S的工具或者服务都有类似的架构。比如连接处理，授权认证，安全等等。

​	第二层架构是MySQL比较有意思的部分。大多数MySQL的核心业务功能都在这一层。**包括查询解析，分析，优化，缓存以及所有的内置函数**(例如：日期，时间，数学和加密函数max,avg,min ,,,,date)，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等。

​	第三层包含了存储引擎。**存储引擎负责MySQL中数据的存储和提取**。和GNU/Linux下的各种文件系统一样,每个存储引擎都各有优劣。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含了几十个底层函数，用于执行诸如**“开始一个事务”**，或者**“根据主键提取一行记录”**等操作。但是存储引擎不会解析SQL*(ps: InnoDB 会解析外键(foreign key)，因为MySQL服务器本身没有实现该功能)*，不同存储引擎之间不会相互通信，只是简单的响应上层服务器的请求。

##### 1.1.1 连接管理与安全性

​	**每个客户端连接都会在服务器进程中拥有一个线程**，这个连接查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。**服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程。** （*MySQL5.5或以上版本支持线程池，可以用池中少量线程来服务大量连接*）

​	当客户端(应用)连接到MySQL服务器时，**服务器需要对其进行认证**。认证基于用户名，原始主机信息和密码。如果使用了安全套接字(SSL)的方式连接，还可以使用X.509证书认证。一旦客户端连接成功，服务器会继续验证客户端是否具有执行某个特定查询的权限。

##### 1.1.2 优化与执行

​	**MySQL会解析查询**，并创建内部数据结构(解析树)，然后对**其进行各种优化**，包括重写查询，决定表的读取顺序，以及选择适合的索引等。**用户可以通过特殊的关键字提示(hint)优化器，影响它的决策过程**。也可以请求优化器解释(explain)优化过程的各个因素，使**用户可以知道服务器是如何进行优化决策的**，并提供一个参考基准，便于用户重构查询和schema，修改相关配置，使应用尽可能高效的运行。

​	优化器并不关心表中使用的是什么存储引擎，**但存储引擎对于优化查询是有影响的**。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特点的查询有优化，关于索引和schema的优化详见第四章与第5章。

​	对于**SELECT**语句，在解析查询之前，**服务器会先检查查询缓存(Query Cache)**，如果能够在其中找到对应的查询，服务器就不必再执行查询解析，优化和执行的整个内容，而是直接返回查询缓存中的结果集。



#### 1.2 并发控制

​	无论何时**，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题**。本章目的是讨论MySQL在两个层面的并发：服务器层与存储引擎层。并发控制是个庞大的话题，有大量的理论文献对其进行过详细的描述。本章只简要的讨论MySQL如何控制并发读写。

​	以Unix系统的email box为例，典型的mbox文件格式是非常简单的。一个mbox邮箱中的所有邮件都串行在一起，彼此首尾相连。这种格式对读取和分析邮件信息非常友好，同时投递邮件也很容易，只要在文件末尾附加新的邮件内容即可。

​	但是如果两个进程在同一时刻对同一个邮箱投递邮件，显然邮箱的数据会被破坏，两封邮件的内容会交叉的附加在邮箱文件的末尾。设计良好的邮箱投递系统会通过锁(lock)来防止数据损坏。如果客户视图投递邮件，有邮箱已经被其他客户锁住，那么只能等待锁释放后才能进行投递。这种锁在实际工作环境中虽然工作效果良好，但不支持并发处理，因为在任意时刻，只有一个进程可以修改邮箱的数据，在大容量邮箱系统中是个问题。

##### 1.2.1 读写锁

​	从邮箱读取数据没有这样的麻烦，即使同一时刻多个用户并发读取也不会有什么问题。因为读取不会修改数据，所以不会出错。但如果**某个用户正在读取邮箱，同时另一个用户试图删除编号为25的邮件**，这个**结果是不确定的**，可能会报错也可能读到了不一致的邮箱数据。为了安全起见，读取邮箱也要特别注意。

​	如果把上述的**邮箱当做数据库中的一张表，把邮件当做一行记录**，就很容易看出同样的问题依然存在。从很多方面来说，邮箱就是一张简单的数据库表。修改数据库表中的记录，与删除或修改邮箱中的邮件信息十分类似。

​	**解决这类经典问题的方法时并发控制**，其实非常简单。在处理并发读或者写的时候，可以通过**实现一个由两种类型的锁 组成的锁系统**来解决问题。这两种类型的锁通常被称为 **共享锁(shared lock)**和 **排他锁(exclusive lock)**，也叫**读锁(read lock)**和**写锁(write lock)**。

​	先不讨论锁的具体实现，描述一下锁的概念如下：读锁是共享的，或者说互不干预的。多个用户可以同一时刻同时读取同一个资源，结果不互相干扰。写锁是排他的，同一时刻只能有一个用户在使用。在实际的系统中，当某个用户在修改某一部分内容时，MySQL会通过锁定防止其他用户读取同一数据，大多数时候，MySQL锁的内部管理都是透明的(不可知)。

##### 1.2.2 锁粒度

​	一**种提高共享资源并发性的方式就是让锁定对象更有选择性**，**尽只锁定需要修改的部分数据，而不是所有资源**。更理想的方式是，**只对会修改数据片进行精确的锁定**。任何时候在给定的资源上，只要相互之间不影响，那么锁定的数据量越少，系统的并发程度越高。

​	**问题是加锁也需要消耗资源**。锁的各种操作，包括获得锁，检查锁是否已经解除，释放锁等都会增加系统开销。如果系统花费大量时间来管理锁，而不是存储数据，那么系统性能就会受到影响。

​	**所谓的锁策略就是在锁的开销和数据安全性之间寻求平衡，这种平衡当然也会影响到性能。**大多数商业数据库系统没有提供更多的选择，**一般都是在表上施加行级锁(row-level lock)，**并以各种复杂的方式实现，以便在锁比较多的情况下尽可能提供更好的性能。

​	而MySQL提供了更多的选择，每种MySQL的存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能。将所粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时又会在另外一些应用场景表现不佳。好在MySQL支持多个存储引擎的架构，不需要单一的通用解决方案。下面将介绍最重要的两种锁策略。

**表锁(table lock)** 

​	**表锁是MySQL中最基本的锁策略**，并且是开销最小的策略。非常类似于前文描述的邮箱加锁机制：它会锁定整张表。一个用户对表进行写操作(插入，删除，更新)前，需要先获得写锁，用来阻塞其他用户对该表的所有读写操作。

​	写锁比读锁的优先级更高，一个写锁请求可能可以插入到**读锁**队列前面。尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种邮箱的表锁来实现不同的目的。例如：**服务器会为诸如 AlTER TABLE 之类的语句使用表锁，忽略存储引擎的锁机制。**

**行级锁(row lock)**

​	**行级锁可以最大程度地支持并发处理(同时意味着最大的锁开销)**。众所周知，在InnoDB和XtraDB以及其他一些存储引擎实现了行级锁。**行级锁只在存储引擎实现，MySQL服务层没有实现。**



#### 1.3 事务

​	在理解事务概念之前，接触数据库系统的其他高级特性还言之过早。**事务** 就是一组原子性的 **SQL查询** ，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。**如果其中有一条语句因为崩溃或其他原因无法执行，那么所有的语句都将无法执行。即事务的内部语句要么全部执行成功，要么全部执行失败。**

​	银行应用是解释 **事务** 的一个经典例子。假设一个银行的数据库有两张表：支票(checking)表和存蓄(savings)表 。现在要从用户 Jane 的支票账户转移200刀 到她的储蓄账户，至少要经过三个步骤：

 1. 检查支票账户余额是否大于200刀

 2. 将支票账户的余额减去200刀

 3. 将储蓄账户的余额增加200到

    上面这个例子是个典型的**事务**，任何一个步骤失败，必须**回滚**所有步骤。

    在MySQL中可以用 ***start transaction*** 语句开始一个事务，然后使用***commit***提交事务，或者***RollBack***撤销所有修改：语句要本如下

```sql
start transaction;
select balance from checking where customer_id=10233276;#假设这是她账号id 
update checking set balance=balcnce-200.00 where customer_id=10233276;
update savings set balance=balcnce+200.00 where customer_id=10233276;
commit;
```

​	单纯的事务概念并不是故事的全部，如果执行到第四条语句服务器崩溃了，用户就会损失掉200刀。一个运行良好的事务处理系统必须具备ACID的特性。ACID意义如下：

  1. **原子性 (atomicity)  **：一个事务必须被视为一个不可分割的最小工作单元，对于一个事务来说不可能只执行其中的某一部分。

  2. **一致性 (consistency) ** ：数据库总是从一个一致性状态转到另一个一致性状态。在前面的例子中，一致性确保了，即使在执行第三，四条语句时服务崩溃了，支票账户也不会损失200刀，因为事务最终没有提交，数据库也不会做出修改。

  3. **隔离性(isolation) **：通常来说，一个事务所做的修改最终提交以前，对其他事务是不可见的。在前面的例子中，假设当执行完第三条语句而第四条还没开始时，此时有另一个账户汇总程序开始运行，其看到的支票账户的余额并没有被减去200刀。**因为它并不知道有另外一个事务对其做了修改**

  4. **持久性(durability)** ：一旦事务提交，其所作修改会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。


​       事务的ACID特性可以确保银行不会弄丢你的钱。而在应用逻辑中，要实现这一点非常难，设置可以说不可能完成。一个兼容ACID的数据库系统，需要做很多复杂但是可能用户并没有察觉到的工作，才能确保ACID的实现。
​       就像**锁粒度**的升级会增加系统开销一样，这种事务处理过程中额外的安全性也会需要数据库系统做更多的额外工作。一个实现了ACID的数据库相比没有实现ACID的数据库，通常会需要更强的CPU处理能力，更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务的存储引擎可以获得更高的性能。即使存储引擎不支持事务也可以通过 ***LOCK TABLES*** 语句为应用提供一定的保护。

##### 1.3.1 隔离级别

​	隔离性其实比想象中要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以完成更高级别的并发，系统开销也更低。

​	下面介绍一下四种隔离级别：

​	1. **READ UNCOMMITTED** (未提交读)：在read uncommitted 级别，事务的修改即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这也被称为**脏读(Dirty Read)**。这个级别会导致很多问题，从性能上来说也没有比其他级别好太多，但却缺乏很多其他级别的好处，所以实际应用中一般很少用。

​	 2. **READ COMMITTED**(提交读)：大多数数据库系统默认隔离级别都是read committed（但是MySQL不是）。read committed 满足前面提到的隔离性的简单定义：一个事务开始，只能看见已提交的事务所做的修改。对其他事务不可见，有时候这个级别也叫 不可重复读(nonrepeatable read), 因为两次执行同样的查询可能会得到不同的结果。

​	 3.**REPEATABLE READ** (可重复读)：解决了dirty read 的问题。该级别保证了在同一个事务中多次读取同样的记录是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个**幻读(Phantom Read)**的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，会产生**幻行(Phantom Row)**。InnoDB和XtraDB存储引擎通过**多版本并发控制（MVCC，Multiversion Concurrency Control）**解决了幻读问题。值得一提的是 可重复读是MySQL的默认隔离级别。

​	 4. **SERIALIZABLE** (可串行化)：最高级别的隔离，通过强制事务串行执行，避免了前面说的幻读问题。简单来说，SERIALIZABLE 会在读取每一行的数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个级别，只有在非常需要确保数据一致性时而且可以接受没有并发的情况下，才会用。

​	用一个简单的表格来说下情况：

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | yes        | yes              | yes        | no     |
| READ COMMITTED   | no         | yes              | yes        | no     |
| REPEATABLE READ  | no         | no               | yes        | no     |
| SERIALIZABLE     | no         | no               | no         | yes    |

##### 1.3.2 死锁

​	死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能产生死锁。同时锁定也会死锁。

​	为了解决这些问题，数据库系统实现了各种死锁检测和死锁超时机制。约复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。还有一种解决方式，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式太被动，不太好。InnoDB现在(当时的现在，2018的以前)的方式是：将持有最少行级排它锁的事务进行回滚。

​	锁的行为和顺序是存储引擎相关的。以同样的顺序执行语句，有些存储引擎会死锁，有些不会。死锁产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免。有些则是完全由于存储引擎实现方式导致。

​	死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序再设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。

##### 1.3.3 事务日志

​	事务日志可以提高事务的效率。**存储引擎在修改表的数据时只需要修改其内存拷贝，再把该行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。**事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的**顺序I/O**，而不是随机I/O需要在磁盘的多个地方移动磁头，所以时间消耗短，更快。**事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回磁盘。**目前大多数存储引擎都是这样实现的，我们通常称之为**预写式日志**(Write-Ahead Logging) ，修改数据需要写两次磁盘。

​	如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体实现方式各存储引擎不一样。

##### 1.3.4 MySQL中的事务

​	MySQL提供两种事务型存储引擎：InnoDB和NDB Cluster。另外还有一些第三方存储引擎也支持事务，比较知名的包括XtraDB和PBXT。

**自动提交(AUTOCOMMIT)**

​	MySQL默认采用自动提交模式。也就是说，**如果不是显式地开始一个事务，则每个查询都被当成一个事务执行提交操作。**在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式

```sql
show variables like 'autocommit'; /*这句是查看是否启动了自动提交*/
set autocomit=1; /*设为1 或 ON表示启动，0或OFF表示禁用。当AUTOCOMMIT=0时，所有查询都是在一个事务中，直到显示执行commit 或者 rollback回滚 该事务结束*/
```

​	修改AUTOCOMMIT对非事务类型的表，比如MyISAM或者内存表，不会有任何影响。对这类表来说，没有commit , rollback的概念。相当于一直处于AUTOCOMMIT 开启状态。

​	还有一些命令，**在执行前会强制执行COMMIT 提交当前的活动事务**。典型的例子，在数据定义语言(DDL) 中，能够**导致大量数据改变的操作**就是这样，比如 **ALTER TABLE**  。 另外还有LOCK TABLES 等其他语句也会导致同样的结果。

​	MySQL可以通过执行 **SET TRANSACTION ISOLATION LEVEL** 等命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前回话的隔离级别。

```SQL
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

​	MySQL能够识别所有的4个 ANSI隔离级别，InnoDB引擎也支持所有的隔离级别。

**在事务中混合使用存储引擎**

​	MySQL服务器层不管理事务，事务是由下层存储引擎实现的。**所以在同一事务中，使用多种存储引擎时不可靠的。**如果在事务中混合使用了两种，在正常提交的情况下不会有问题。但是如果要回滚，非事务型的表上变更无法撤销，会导致数据库处于不一致状态，这种情况很难修复。所以对每张表选择一个合适的存储引擎很重要。

**隐式和显式锁定**

​	InnoDB采用的是**两段锁定协议(two-phase locking protocol)**。在事务执行过程中，随时可以执行锁定，锁只有在执行commit，或者rollback的时候才会释放。并且所有的锁都是在同一时刻释放。前面描绘的锁都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。另外InnoDB也支持通过特定语句进行显示锁定。

```sql
select .... lock in share mode
select .... for update   /*这两个句子不属于 SQL规范*/
```

​	**MySQL也支持Lock tables 和Unlock tables 。这些在服务器层实现，和存储引擎无关。经常可以发现应用已经将表从MyISAM转到InnoDB，但是还是显示地使用 Lock Tables 。这回严重影响性能，实际上InnoDB的行级锁工作的更好。**

> lock tables 和事务相互之间影响的话，情况会变得非常复杂。在某些MySQL版本汇总甚至会产生无法预料到的结果。因此本书建议，除了事务中禁用AUTOCOMMIT，可以使用lock tables 外，其他任何时候都别用。不管什么存储引擎。



#### 1.4 多版本并发控制（MVCC）

​	***MVCC只在REPEATABLE READ 和 READ COMMITTED两个级别下工作。***因为READ UNCOMMITTED总是读取最新行的数据，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。

​	MySQL的大多数事务型存储引擎的实现都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL 还包括Oracle，PostgreSQL等其他数据库系统也都实现了MVCC，虽然实现的机制不尽相同。因为MVCC没有同意标准。

​	可以认为MVCC是行级锁的一个变种，在很多情况下避免了加锁的操作，因此开销更小。并且大都实现了非阻塞的读操作，写操作也只锁定必要的行。

​	**MVCC的实现是通过保存数据在某个时间点的快照来实现的。**也就是说，不管执行多长时间，每个事务在**事务期间**看到的数据都是一致的。**根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能不一样。**即事务看到的数据取决于事务开始的时间。

​	**InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，另一个保存行的过期时间（删除时间）**。存储的不是实际的时间值，而是系统版本号。每开始一个事务，系统版本号都会自动递增，**事务开始时刻的系统版本号会作为事务的版本号**，用来和查询到的每行记录的版本号进行比较。下面看下在REPEATABEL READ隔离级别下，MVCC具体如何操作。

---

**SELECT**

​	InnoDB会根据下面两个条件检查每行记录：

​	a. InnoDB只查找版本号早于当前事务版本的数据行，这样可以确保事务读取的行要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。

​	b. 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。

**INSERT**

​	InnoDB为新插入的行保存当前系统版本号为行版本号

**DELETE**

​	InnoDB为删除的每一行保存当前系统版本号作为行删除标志

**UPDATE**

​	InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标志

---

​	**保存这两个额外系统版本号，使大多数读操作都可以不用加锁。**这样设计使得读数据操作很简单，性能很好，并且也保证只会读取到符合标准的行。不足之处就是每行都需要耗费额外的资源来管理存储空间。

​	

#### 1.5 MySQL的存储引擎

​	在文件系统中，MySQL将每个数据库(或schema)保存为数据目录下的一个子目录。创建表时会在数据库子目录下创建一个与表同名的 **.frm**文件保存表的定义。例如创建一个 MyTable 的表，就有 MyTable.frm文件保存该表的结构。 **在Windows中大小写不敏感，在类Unix中则是敏感的**。不同的存储引擎保存数据和索引的方式不同。但表的定义则是在MySQL服务层统一处理。

​	可以使用`show table status like 'tablename' \g` 命令来查看表的相关信息。这里显示的一些信息就不详细列举了，挑几个我觉得重要经常用的讲吧。

 	1. 我们定义列的时候，要定义它的数据类型 char 或是 varchar 两个实际上不一样，像varchar 和 blob 是可变长度的字段，char和integer 是固定长度的。
 	2. 表中的行数，对于其他存储引擎来说是精确值，InnoDB是估计值。

​	InnoDB是MySQL主推的存储引擎，它可以处理大部分我们遇到的问题。它被设计用来处理大量的短期事务。以及性能优越和自动崩溃恢复特性使得它在非事务型存储的需求也很大。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。

​	**InnoDB 表是基于聚簇索引建立的**，聚簇索引对主键查询有很高的性能。不过它的二级索引(secondary index,非主键索引) 中必须包含主键列，所以如果主键列很大的话，其他所有索引都会很大。因此表上的索引较多的话，主键应当尽可能小。InnoDB的存储格式是平台无关的，可以将数据和索引文件从Intel平台复制到PowerPC或者Sun SPARC平台。Intel平台 就是我们常用的PC，以及AMD系列的CPU平台，通常使用x86，CISC技术，一般使用Windows操作系统。 其他两个平台就不说了。

​	MySQL还包含大量其他的存储引擎，像是MyISAM，NDB Cluster ，Memory....以及第三方存储引擎API，如**XtraDB**：是Percona公司的产品，它是I**nnoDB的改进版本**。主要改进点集中在**性能，可测量性和操作灵活性**上面。XtraDB完全可以作为InnoDB的替代品，**兼容InnoDB**的所有查询操作和读写操作。还有**面向列的存储引擎**，MySQL默认是面向行的。在大量数据处理时，面向列的方式可以传输更少的数据所以效率更高，压缩率也更高。其中Infobright 是最有名的。在非常大的数据量（数十TB）时，该引擎工作良好。是为数据分析和数据仓库设计的。还有大量其他存储引擎就不说了。想知道可以google。



##### 1.5.1 选择适合的存储引擎

​	在大多数的情况下，InnoDB都是正确的选择。**除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎**。

##### **日志型应用**

​	假设需要实时记录一台中心电话交换机的每一通电话的日志到MySQL中，或者通过Apache的*mod_log_sql*模块将网站所有访问信息直接记录到表中。这一类应用的插入速度有很高的要求，数据库不能成为瓶颈。MyISAM或者Archive存储引擎对这类应用比较合适，因为它们开销低，而且插入速度非常快。

​	而如果要对**记录的日志做分析报表**，就会有点麻烦。因为**生成报表的SQL很有可能导致插入效率明显降低**。这是一般有两种解决方案:

 	1. 利用MySQL内置的赋值方案将数据复制一份到备份库，然后在备份库上执行比较消耗时间和CPU的查询。这样主库只用于高效的插入工作，而备库上执行的查询也无须担心影响到日志的插入性能。
 	2. 在日志记录表的名字中包含年和月的信息，比如 *web_logs_2012_01* ，这样可以在已经没有插入操作的历史表上做频繁的查询操作，不会干扰到最新的当前表上的插入操作。



##### **在只读或者大部分情况下只读的表**：

​	如果不介意MyISAM的崩溃恢复问题，选择它是合适的。不过不要低估崩溃恢复的重要性，有些存储引擎不会保证将数据安全写入硬盘，MyISAM只将数据写到内存中，然后等待操作系统定期将数据刷出到磁盘中上。

>一个值得推荐的方式是：在性能测试环境模拟真实环境，运行应用，然后关闭电源模拟崩溃测试。对崩溃恢复的第一手测试经验是无价之宝，可以避免真的碰到崩溃时手足无措。

​	不要轻易相信MyISAM比InnoDB快之类的经验之谈，很多场景中InnoDB比MyISAM快很多，尤其是用到聚簇索引或者需要访问的数据可以放入内存的应用。

##### 订单处理

​	如果涉及订单处理，一定是事务型的。InnoDB就是最佳选择

##### 电子公告牌和主题讨论论坛

​	对于MySQL用户，主题讨论区是很有意思的话题。当前有成百上千个基于PHP或者Perl的免费系统可以支持主题讨论。其中大部分数据库操作系统效率都不高，因为它大多倾向于一次请求尽可能多的查询语句。

​	主题讨论区一般都有更新计数器，并且会为各主题计算访问统计信息。**多数应用只设计了几张表来保存所有的数据，所以核心表的读写压力十分大。**为保证这些核心表的数据一致性，锁称为资源争用的主要因素。尽管设计有缺陷，但是在大多数应用在低负载时可以工作得很好。如果Web站点规模迅速扩大，流量随之猛增，则数据库访问可能变得非常慢。此时**典型的解决方案是更改为支持更高读写的存储引擎，但是有时会发现系统变得更慢了**

​	用户可能没有意识到这是由于特殊的查询语句引起的，比如：

```sql
select count(*) from tablename;
```

​	问题就在于，不是所有存储引擎运行上述查询都非常快。对于MyISAM确实很快，但是其他的不行，**后面会有演示如何发现并解决存在的这类问题。**

##### 大数据量 

​	InnoDB数据库单机的数据量在3—5TB之间或者更大些。如果在10TB往上走可能就需要建立数据仓库,Infobright是MySQL数据仓库最成功的的解决方案。TokuDB也是一种选择。

##### 转换表的存储引擎

```sql
alter table tablename engine=MyISAM;
```

​	简单一句就可，但是执行的时间会很长。MySQL会按行将数据从原表复制到一张新表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上回加上读锁。所以在繁忙的表上执行此操作要特别小心。可以进行手工的导入和导出，避免此问题。**还有转换间会失去所有原存储引擎的特性，从InnoDB转到MyISAM再转回来，所有的外键都会丢失。**



##### 导入和导出

​	可以使用***mysqldump***工具将数据导出到文件，然后**修改文件中的create table语句的存储引擎选项。**注意要同时**修改表名**，因为同一数据库不能存在表名相同的表即使存储引擎不一样。**同时mysqldump 会默认在create table之前加上drop table 语句**，**不注意这点可能导致数据丢失**。



##### 创建于查询(create 和 select)

​	第三中转换技术综合了第一种的高效和第二种的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，利用 insert.....select 语法来导出数据。数据量不大时：

```sql
create table innodb_table like myisam_table;
alter table innodb_table engine = InnoDB;/*将新创建的表引擎改为InnoDB ，新表没有数据，所以很快*/
insert into innodb_table select * from myisam_table;
```

​	如果数据量很大时，可以分批处理，针对每一段数据执行事务提交操作。

```sql
start transaction;
insert into innodb_table select * from myisam_table where id between x and y;/*将id处于x与y之间的复制到innodb_table*/
commit;
```



#### 1.6 MySQL时间线(TimeLine)

​	介绍MySQL从诞生到后面5.6版本的发展，其实现在已经有8.0+了，时间应该是过了7年了。这里就不写了。

#### 1.7 MySQL的开发模式

​	讲述了Oracle接手MySQL后关于收费的模式，延续了遵循GPL开源协议，全部源代码开放给社区。为付费用户提供单独一些服务器插件。

#### 1.8 总结

​	MySQL拥有分层的架构。上层是服务器层的服务和查询执行引擎，下层是 存储引擎。虽然有很多不同作用的插件API，但存储引擎API还是最重要的。如果能够理解MySQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MySQL的核心基础架构的精髓。

​	MySQL最初基于ISAM(后来被MyISAM取代)，其后陆续添加了更多的存储引擎和事务支持。MySQL有一些怪异的行为是由于历史遗留问题导致的。例如在执行**ALTER TABLE** 时MySQL提交事务的方式是由于存储引擎架构直接导致的，并且数据字典也保存在*.frm*文件中。

 	当然，存储引擎API的架构也会有一些缺陷。有时候选择多并非好事。所以很高兴InnoDB能够满足95%以上的用户需求。Oracle一开始收购了InnoDB之后又收购了MySQL，这一举动可以说是很明智的。InnoDB和MySQL服务器之间可以更快的协同发展。并且基于GPL开源协议开放全部源代码，社区和客户都可以获得坚固而稳定的数据库。MySQL正在变得越来越可拓展和有用。



---

于2018.11.25 看完第一章。这一章看了之后真的感觉很有用，特别是对我这样的刚开始学习MySQL的学生而言。虽然这本书已经是几年前发行的了，但是这种基础知识除非发生很大的变革，在未来很久时间应该不会改变。虽然没有教我怎么写好SQL语句，但是不得不说这章写的非常好。

接下来我会在未来的几个月内尝试看完，不过我感觉很难。













