参考自 [SQL性能优化](https://zhuanlan.zhihu.com/p/46633318)

这里只给出一些简单的优化Tips

1.少用 `select *` :  很明显会增加查询的消耗

2.**IN 包含的值不应该过多**： IN 这个操作本身消耗就高，如果IN里面是连续的数值可以用**between** 代替，IN里面的字段如果添加了索引效率还是可以的，大约1万条数据以内。

3.**in和exists，not in和not exists**：exists以外层表为驱动表，先被访问，适合于外表小、内表大的情况。in则是先执行子查询，适合外表大、内表小的情况。

not in不推荐使用，因为效率实在太低了。

```sql
select name form user where id in (select id from grade where score>60);

select name form user where exists (select * from grade where score>60);# 返回的字段并没有意义，只在乎是不是有返回集
```

in 只允许子句返回一个字段，如上面的id，而exists可以有多个，并且exists强调是否返回结果集，不要求知道返回什么。

4.**少用or同时多用union all代替union**：or两边的字段如果有不走索引的会导致整个查询都不走索引，导致效率大大降低。

union 合并两个或多个 SELECT 语句的结果集。union all和union二者的区别就是 union 是将两个结果合并之后再进行唯一性的过滤操作，效率会比union all低很多。union all 可以允许重复数据

5.**分段和分页查询**：在扫描行数较多的情况下可以采取分段查询、循环遍历、结果合并处理、使用合理的分页方式、**在数据表量逐渐增加的时候、limit分页查询的效率会降低**

- select id,col from table limit 1000,10;   从第1000个记录开始之后的10个记录

6.**尽量使用索引**：

- 查询条件 like "%abc" 是不使用索引的
- join中主键和外键的数据类型不相同时 不使用索引
- order by中 排序条件是一个查询条件表达式的情况下 不使用索引

如果某个数据列里包含许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个字段里都是0|1等值，就没必要为他建立索引

**复合索引**：MySQL从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。例如索引是key index (a,b,c) 可以支持 a  a,b   a,b,c  3种组合进行查找，但不支持b，c进行查找。 

当最左侧字段是常量引用时，索引就十分有效，复合索引可以**只使用复合索引中的一部分**，但必须是由**最左部分开始**，且可以存在常量。









