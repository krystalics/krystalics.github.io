从用户点击一个URL链接开始解释HTTP的工作原理：假设URL是 `http://www.rbooks.top/mypage?userid=0`

1.浏览器会分析该URL

2.分析完之后浏览器向DNS请求解析 `www.rbooks.top`的IP地址

3.DNS将解析出的IP地址`47.102.119.234`返回给浏览器

4.浏览器与服务器建立TCP连接(默认是80端口)

5.建立TCP连接之后，浏览器开始请求文档 `GET /mypage?userid=0` 

6.服务器给出响应，将数据返回给浏览器

7.释放TCP连接

8.浏览器开始渲染服务器传过来的数据

HTTP的报文是怎么样的呢？真实的http请求如下：

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/48.png?raw=true">

状态码分为5类：指明特定的请求是否被满足，如果没有满足，原因是什么：

| 状态码 | 含义       | 例子                             |
| ------ | ---------- | -------------------------------- |
| 1xx    | 通知信息   | 100=服务器正在处理客户请求       |
| 2xx    | 成功       | 200=请求成功                     |
| 3xx    | 重定向     | 301=页面改变了位置               |
| 4xx    | 客户错误   | 403=禁止的页面；404=页面未找到   |
| 5xx    | 服务器错误 | 500=服务器内部错误；503=以后再试 |



相关知识点：

[简述TCP连接的建立与释放](https://zhuanlan.zhihu.com/p/24860403)

TCP是面向连接的运输层协议，它是可靠交付，全双工的，面向字节流的点对点服务。HTTP协议便是基于TCP协议实现的。相比于网络层着力解决主机间的通讯，运输层则是着眼于应用进程之间的通信，所以我们常说的端口，套接字都是运输层上的概念。TCP协议的报文格式如下：

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/45.png?raw=true">

seq（序号）：TCP连接字节流中每一个字节都会有一个编号，而本字段的值指的是**本报文段所发送数据部分的第一个字节的序号**

ack（确认号）：表示期望收到的下一个报文段数据部分的第一个字节的编号，编号为ack-1及以前的字节已经收到。

SYN ：当本自担为1时，表示这是一个连接请求或者连接接受报文

ACK：仅当本字段为1时，确认号有效

FIN：用来释放一个连接，当本字段为1时，表示此报文段的发送端数据已经发送完毕，要求释放运输连接。

讲完了基本的内容之后，重点来了。TCP运输连接分为三个阶段：连接建立，数据传送以及连接释放。运输连接管理就是连接建立以及连接释放过程的管控，使其能正常运行，达到这些目的：使通信双方能够通知对方的存在，可以允许通信双方协商一些参数（最大报文段长度，最大窗口大小等等），能够对运输实体资源进行分配（缓存大小等）。TCP连接的建立采用C-S模式：主动发起请求的叫Client，被动等待连接的应用进程叫做Server。

- 第一次握手：客户端的应用进程主栋打开，并向服务端发出请求报文段。其首部中：SYN=1，seq=x
- 第二次握手：服务器应用进程被打开。若同意客户端请求则发回确认报文，其首部中：SYN=1，ACK=1，ack=x+1,seq=y
- 第三次握手：客户端收到确认报文之后，通知上层应用进程连接已经建立，并向服务器发出确认报文，其首部：ACK=1，ack=y+1 。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已经建立

这个过程用图来表示如下：其中CLOSED：关闭状态，LISTEN：收听状态，SYN-SENT：同步已发送，SYN-RCVD：同步收到，ESTAB-LISHED：连接已建立

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/46.png?raw=true">

通俗的说就像两个人在打招呼：

A：你准备好了吗

B：我准备好了

A：好那我开始了。



释放阶段：

- 第一次挥手：数据传输结束以后，客户端的应用进程发出连接释放报文，并停止发送数据，其首部：FIN=1,seq=u
- 第二次挥手：服务器收到释放报文，发出确认报文。首部：ack=u+1,seq=v。此时本次连接就已经进入了半关闭状态。客户端不再像服务器发送数据。而服务器会继续发送
- 第三次挥手：若服务器已经没有要想客户端发送的数据，其应用进程就会通知服务器释放TCP连接。这个阶段服务器锁发出的最后一个报文的首部应为：FIN=1，ACK=1，seq=w，ack=u+1
- 第四次挥手：客户端收到释放报文后，必须发出确认：ACK=1，seq=u+1 ，ack=w+1 。再经过2MSL（最长报文端寿命）后，本次TCP连接真正结束。通信双方完成了他们的告别。

图示如下：ESTAB-LISHED：连接建立状态，FIN-WAIT-1：终止等待1状态，FIN-WAIT-2：终止等待2状态，CLOSE-WAIT：关闭等待状态，LAST-ACK：最后确认状态，TIME-WAIT：时间等待状态，CLOSED：关闭状态

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/47.png?raw=true">

通俗的说就是：两个人在辩论

A：一段时间之后，我已经讲完了，该你了 。此时A从连接建立状态到了终止等待1状态

B：在听了A的辩论之后，你真的讲完了？此时B开始组织语言，

等待一段时间没有响应之后，B开始讲他的部分 ，此时B处于关闭等待状态，等待它的话说完

B：讲了一段时间之后，我也讲完了，你还有什么补充的吗。此时B已经没有话说了，处于最后确认状态

A：我也没有了，你呢？A处于 时间等待状态

等待一段时间没有回应后，结束辩论



关于TCP为什么要这么设计的一些点：

1.在握手与挥手的过程中，往复的ack和seq有什么含义？

这是通信双方在通信过程的确认手段，确保双方通信的正确性。

2.在结束连接的过程中，为什么在收到服务器端的连接释放报文之后没有立刻结束连接，而是等待了2MSL之后才真正关闭。

这里由两个原因：

(1)，需要保证服务器收到了客户端的最后一条确认报文。假如这条报文丢失，无法做出响应，就造成了服务器不停重传连接释放报文，导致无法正常进入关闭状态。而等待2MSL，可以保证服务器收到最终确认报文；若服务器没有收到，在2MSL之内，客户端会收到服务器的重传报文，来询问(你还有没有要补充的？)，此时客户端会重新传输确认报文，并重置计时器

(2)，存在一种“已失效的连接请求报文”：当客户端发出连接请求报文，而服务器端没有收到，客户端会重新发出一条请求报文，成功建立连接。然而，第一条请求并没有丢失，而是在某个节点逗留时间过长，随后它也到达了服务器，它会让服务器以为客户端又发送了一条请求，从而造成异常。









