参考文章：

[认识微服务——一颗银弹](https://insights.thoughtworks.cn/microservices/)

##### MicroServices Architecture 微服务架构

Martin Fowler的关于它的定义是:

> 微服务架构是一种架构模式,提倡将单一应用程序划分为一组小的服务,服务之间互相协调,互相配合,为用户提供最终的价值.
>
> 每个服务都是一个进程,是一个独立开发的程序.服务之间采用轻量级的通信机制互相沟通(Http的RestFul API)

像是现在主流的开发都是前后端分离,做了最基本的微服务模型.但是要扩展就可以将前后端的各个模块都进而独立出来,做成一个个的程序,通过http协议互相协调,分别部署到不同的机器中.再往后发展,每个服务都由多台机器来提供,这就是分布式，由此衍生出更多的问题。

现在顶级的大公司，它们的数据中心都是这种模式。[请看我的另一篇文章](https://krystalics.github.io/2018/12/10/Architecture-%E8%AF%BE%E5%A0%82%E6%95%B4%E7%90%86/#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84)   

像这种微服务架构的开发，必然会有很多个程序需要上线部署，所以催生出来了另一个概念DevOps，开发+运维 每个服务都由开发人员负责维护，这样大大减少运维人员的负担。

##### 为什么要设计出微服务这种东西呢？

在企业中某个项目或系统有时参与人数多达几十人，每个人写的代码交织在一起，即使是使用最好的设计，到最后需求变更或者做拓展的时候都会涉及到多个人的协调，往往一个人事不敢修改其他人的代码的，这是要担责任地。

而微服务提出以业务为边界作为模块划分原则，每个模块独立进程。一个业务由很多小的业务独立组成，很大程度上解决了这种问题。但是这种解决方案其实并没有降低难度，因为分在不同的服务中就会导致模块之间的连接更加复杂，网络通讯的不可靠和性能损耗(网络连接的速度可远远比不上内存)，还有使用的协议也要一致，接口对接转换，版本协作(可能两个服务的版本不一致)，分布式业务与数据一致性都是只有一台机器一个程序不需要考虑的问题。

微服务只是降低了单个服务的复杂性，却让整个系统的复杂性上升了。下面的图表示了各个服务之间的关系。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/2-modularized.jpg?raw=true">

这些都是微服务推广初期(现在也是)面临的问题，其实就是缺乏一个功能齐全的PaaS，比如AWS/Azure等，用来解决这些附属问题。企业只需要将应用开发好，放在AWS的服务器上跑就好了。因为PaaS日渐成熟，包括国内的阿里，腾讯等，企业并不需要在这方面消耗太大的成本。

因为各个模块都被服务化了，所以可以更早的拿出去和客户见面，这就是微服务强调小，独立业务，独立进程独立部署交付的价值。下图展示微服务下的开发部署方式

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/54.png?raw=true">

说完了概念的东西，我们来说说微服务架构需要的辅助程序吧，以SpringCloud为例

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/55.png?raw=true">

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/56.png?raw=true">

通过上面的结构图可以很清晰的看到整个架构在应对请求的时候是怎么工作的，这里详细的介绍一下各个组件的作用。

- Robin：负载均衡
- Eureka：注册服务中心，所有的服务都在注册中心注册，负载均衡也是通过在注册中心注册的服务来使用一定策略实现的，Eureka可以有多个来保证高可用
- Zuul：路由配置网关，判断一个URL请求的是哪个服务，请求会转发到负载均衡中
- Hystrix：断路器，及时处理服务的错误，防止其中一个服务出现问题而导致整个系统崩溃，Hystrix DashBoard 监控面板，提供一个可视化界面，可以监控各个服务商服务调用所消耗的时间，Turbine监控聚合，也是使用Hystrix，把所有的监控信息聚合到一起来统一查看。
- SpringCloud Config：统一的配置管理

**微服务中的每个服务都可以是不同的编程语言实现的**。采用不同的技术必然会带来诸多问题

1.各种服务是否可以任意使用自己的技术，自己的组件，框架呢？比如Java的SpringBoot和Python的Django，如果这样势必会带来更大的管理困难，维护困难，技术共享困难。

2.公共的方法如何实现共享？如格式化时间的一个简单方法需要共享，也要封装为服务接口吗？

这方面的总体策略是：仍然需要统筹考虑，所有组件统一管理，组件放置在产品仓库中，每个产品或服务需要共享组件时，从产品仓库获取。特殊情况需要用到特殊的组件，框架则申请决策。



讲了这么多，还不知道一个微服务的应用是怎么上线的

1.功能划分：对产品功能进行拆分，分成若干个微服务，一个功能可以创建多个微服务并部署在多个服务器的节点上进行负载均衡；具体如何拆分，规则如下

- 粒度微小：总的原则就是高内聚，低耦合
- 责任单一：每个服务只做一件事
- 隔离性：每个服务相互隔离，不互相影响
- 业务无关性：一些基础服务与业务无关的：比如短信服务，邮件服务，这些是最容易划分出来的。

2.设计原子服务层，树立和抽取核心应用，公共应用，作为独立的服务下沉到核心和公共服务层，逐渐形成稳定的服务中心，使应用能更快速的响应多变的客户需求

3.为每个服务都设计API接口（Rest方式）

4.为不同的服务分类，不同类型的服务需要资源不同，可以配置不同的资源，包括CPU，内存，和磁盘



为实现负载均衡，允许相同服务在多个节点注册相同的服务名，不同的端口。如果没有前期的规划，不同服务提供着可能会注册相同的服务名，导致消费者调用服务时产生调用混乱。因此服务名需要统一规划：

- 规划期统一制定每个服务提供者的服务名或者模块标识
- 服务名的命名规则：ModuleName_ServiceName，且所有字符小写。不同单词之间使用下划线分隔。如果用户管理模块提供了获取用户信息的服务，则命名为 user_get_info
- 新增服务名时需要提出申请，审批通过后方可使用。为了减少审批复杂度，可只审批ModuleName，即在模块内部可以自由增加服务名而不需要审批



开发策略：每个服务都开一个代码仓库，问题就是需要集成服务的时候比较困难。每个服务的代码都是独立编译，打包，杜绝相互依赖。都采用持续集成等等，，



##### 还会遇到一个大的问题：数据库

每个服务都要有自己的数据库吗？那需要join的时候该怎么办呢？

- 严格按照微服务的划分来做，数据库也是相互独立的，需要联合数据的时候调用各个服务的接口来获取数据，然后再写逻辑去处理这些原始数据。这是标准的做法，也是最麻烦的
- 将业务高度相关的表放在一个库中，将业务关系不是很紧密的表分散到各个数据库中。。这是折中，但是这样会导致功能划分比较难以遵循微服务的架构
- MySQL+MHA 高可用架构，MySQL分布式Proxy视频扩展架构、MySQL缓存高并发读架构，MySQL小文件系统大字段存取架构，MySQL Inforbright/Greenplum 统计分析架构
- 和第一种类似，也是分库来满足业务高并发，但它**实时或者准时将个微服务的数据库同步到NoSql数据库汇总，在同步的过程中进行数据清洗**，用来满足后台业务的使用。推荐使用MongoDB，HBase等



##### 微服务中的负载均衡

印象中的负载均衡就是通过一个或多个服务器统计每个服务的连接数，平均分配连接来实现的，这样可以通过增加负载均衡服务器达到更快更好的分配连接，微服务中不再采用一般的增加负载均衡服务器的方式进行负载均衡，如F5，Nginx，LVS等。

而是把负载均衡的功能以库的方式集成到服务消费方的进程中，这种方式称之为软负载均衡或者客户端负载均衡，在SpringCloud中配合Eureka的服务注册功能，Ribbon子项目则为REST客户端实现了负载均衡

Ribbon的工作原理分为如下4步：

- Ribbon首先根据其所在Zone优先选择一个负载较少的Eureka Server（因为用户的连接都是通过Eureka来查询服务所在地的，所以Ribbon需要选择一个连接较少的服务器）
- 定期从Eureka Server更新并过滤实例列表
- 根据指定的负载均衡策略，从可用的服务器列表中选择一个服务实例的地址。以下大致说一下策略：
  - RoundRobinRule：轮询策略——默认策略，循环服务器看哪个服务器的连接较少
  - RandomRule：随机选择，
  - BestAvailableRule：最大可用策略，即先过滤出故障服务器，然后选择当前并发请求数最少的
  - ....
- 然后通过RestClient进行服务调用



##### API网关调用

所有服务通过Zuul网关进行调用，不允许直接调用我们提供的业务服务。所以Zuul可能会成为系统的性能瓶颈，在项目复杂的时候可以考虑使用 主备模式或者多个Zuul的负载均衡、

##### 同步调用

采用Http Rest方式进行调用，针对业务需求可以进行负载均衡，负载均衡的方式一般有两种

- FeignClient （建议使用）
- RestTemplate

不管什么方式都是通过REST接口调用服务的HTTP接口，参数和结果默认都是通过Jackson序列化和反序列化。因为Spring MVC的RestController定义的接口，返回的数据都是通过Jackson序列化成JSON的数据。

##### 异步调用

**可选方案**：RabbitMQ和kafka，Spring Cloud Stream

Spring Cloud Stream，基于Redis，Rabbit，Kafka实现的消息微服务，简单声明模型用以在SpringCloud应用中收发消息。

##### 权限验证

- 一般我们都是通过登录获得的token或者cookie方式才能获得访问接口的权限的
- 使用Spring Cloud Netflix框架，登录的时候会把登录请求转发到相应的用户服务上，登录成功之后，会设置cookie或header token等。然后客户端接下来的请求就会带着这些验证信息，从Zuul网关传到相应的服务上进行验证
- Zuul网关把请求转发到后台的服务的时候，会默认把一些header传到服务端，如Cookie，Set-Cookie，Authorization。这样，客户端请求的相关headers就可以传递到服务端，服务端设置的cookie也可以传到客户端。

##### 日志管理

不同微服务部署在不同的节点上，登录每个节点查看日志是比较麻烦的，同时对于需要关联多个微服务日志联合查看分析的情况会变得更加的麻烦。随着节点变多，如果没有合适的管理机制和工具，定位问题，发现问题的复杂性变得更加的庞大。所以一个统一的日志管理是非常有必要的

1、建立统一的日志管理规范

2、开发并使用统一的日志组件，为所有微服务提供统一的日志服务，由log4j或Blitz4j封装

3、在每个服务节点上部署日志采集Agent组件，由Agent进行日志的采集和转发

4、建立统一的日志中心，将所有日志都写入日志中心



##### API调用链追踪

微服务架构上通过业务来划分服务，通过REST调用，对外暴露的一个接口可能需要多个服务协同才能完成，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务不断扩张，服务之间互相调用会越来越复杂

Spring Cloud Sleuth主要功能是在分布式系统中提供追踪解决方案，并且兼容了zipkin，你只需要在pom文件引入相关依赖就可以



##### 持续集成

每个微服务独立持续集成，由统一的集成工具，实现自动化的版本集合，将所有微服务集成到统一的版本发布包中。持续集成可制作多种场景的版本，包括测试环境，开发环境，生产环境。统计测试覆盖率等指标数据。像是Jenkins和Sonar等工具

##### 持续部署

1、通过持续集成自动制作发布版本的Docker镜像

2、将docker镜像自动上传到docker容器中

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/57.png?raw=true">

嗯，科普到此结束，看的我脑壳疼。



















