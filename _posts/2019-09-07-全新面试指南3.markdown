记录我认为比较重要的可能在面试中会遇到的一些问题，点

---

##### 线程池的工作原理

[线程池ThreadPoolExecutor的实现原理](https://juejin.im/post/5aeec0106fb9a07ab379574f)

这里的线程池指的是**ThreadPoolExecutor** ，其中的参数我已经知道了意思，这里就是从整体流程来明确一下它的过程

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/58.png?raw=true">

其中拒绝策略也叫饱和策略，分为以下四种：

- AbortPolicy ： 直接拒绝该任务，并抛出`RejectedException`  **默认的拒绝策略**
- CallerRunsPolicy ：只用调用者所在的线程来处理该任务
- DiscardPolicy ：不处理直接丢弃掉任务
- DiscardOldestPolicy ：丢弃掉阻塞队列中存放最久的任务，执行当前任务。

简单的说一下参数：

```java
ThreadPoolExecutor(int corePoolSize, //核心线程数
                              int maximumPoolSize, //最大线程数
                              long keepAliveTime, //非核心线程无任务时的生存时长
                              TimeUnit unit, //生存时长的 单位，比如TimeUnit.Second 秒
                              BlockingQueue<Runnable> workQueue, //阻塞队列
                              ThreadFactory threadFactory, //线程工厂
                              RejectedExecutionHandler handler //拒绝策略) 
```

其中，阻塞队列可以选择 ArrayBlockingQueue 有界队列和 LinkedBlockingQueue 无界队列。要慎用无界队列，它的没有边界，意味着可能有很多任务都会压在队列中，导致内存不够用。

至于其中的 ThreadFactory，有默认的线程工厂 直接就会创建ThreadPoolExecutor。也有很多现成的类型，**所以我们一般不自己创建ThreadPoolExecutor，而是使用Executors的各种工厂方法**。

- Executors.newCachedThreadPool() ：创建一个可缓存的线程池，如果线程池长度超过处理需求，可回收空闲线程，若无可回收则会创建新线程

  ```java
  public static ExecutorService newCachedThreadPool() {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
  }
  ```

- Executors.newFixedThreadPool()：创建一个长定线程池，可控制最大并发数，超出的线程在队列中等待 其中核心线程数等于最大线程数

- Executors.newShceduledThreadPool()：创建一个定长线程池，支持定时及周期性人物执行

- Executors.newSingleThreadExecutor ()： 创建一个单线程化的线程池，用唯一的工作线程保证所有任务按照指定顺序FIFO,LIFO或者优先级执行

像线程池提交任务(该任务必须是 Runnable或者 Callable)，有里两种方法

- executor.submit(task); 这个会返回一个Future，调用get()方法可以获得该任务的执行结果，但是调用future.get() 的线程会阻塞至拿到结果
- executor.execute(task); 这个不需要返回结果，直接提交



是在想自己创建，并且自己制定线程的创建策略 ，就可以如下：

```java
ThreadFactory factory=new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r);
    }
};
BlockingQueue workQueue=new ArrayBlockingQueue(10); //阻塞队列长度为10
//核心线程 10  最大线程20 非核心线程空闲时间60秒，阻塞队列 10，工厂如上
ThreadPoolExecutor executor=new ThreadPoolExecutor(10, 20, 60, TimeUnit.SECONDS, workQueue,factory);
```



##### MySQL 的索引

[什么时候会使用索引？](https://krystalics.github.io/2019/03/22/java%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/#13%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E5%B0%A4%E5%85%B6%E6%98%AFmysql) 

[CyC MySQL](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md) 



##### Redis

[CyC2018 Redis](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)

##### 其他知识——内存模型，

[Java内存泄露](https://krystalics.github.io/2019/04/25/Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/)

[本人OPPO 实习面试总结](https://krystalics.github.io/2019/05/10/OPPO%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/) 

[本人帆软 实习面试总结](https://krystalics.github.io/2019/05/29/%E5%B8%86%E8%BD%AF%E9%9D%A2%E8%AF%95/) 

##### IO

[Reactor与Proactor](https://krystalics.github.io/2019/08/06/Reactor%E4%B8%8EProactor/) 

[Java IO详解](https://krystalics.github.io/2019/07/18/java.io%E8%AF%A6%E8%A7%A3/)

[Java NIO详解](https://krystalics.github.io/2019/07/19/java.nio%E8%AF%A6%E8%A7%A3/)

[CyC2018 Java IO](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md)

##### 大量数据排序去重

[内存限制的大量数据排序](https://krystalics.github.io/2019/08/05/%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E7%9A%84%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/) 

##### Java 并发

[CyC2018 Java并发](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md)

##### Java 虚拟机 

[CyC2018 Java虚拟机](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

##### 集合类库

[CyC2018 java容器](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md)

##### SpringBoot 

[自动配置](https://segmentfault.com/a/1190000018011535)

关键是 `@EnableAutoConfiguration`启用自动配置，内部实际上是去加载 `META-INFO/spring.factories`文件的信息后，筛选出`EnableAutoConfiguration`为key的数据，加载到IOC容器中，实现自动配置。

- 而`META-INFO/spring.factories`是指 所有jar 包下的该文件，将其包装到Properties对象中
- 从Properties对象获取到key值为`EnableAutoConfiguration`的数据，然后添加到容器里面