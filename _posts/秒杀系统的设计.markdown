面试被问到了秒杀系统，由于之前没有做过这样的业务，回答的不尽人意（只说了下redis缓存拦截请求到数据库的操作），所以专门抽出时间来学习一下 秒杀的思路。 文章主体来自 [知乎的各大佬的回答](https://www.zhihu.com/question/54895548) 这里只是借鉴一下

-------------------------------------------------------------------------

秒杀系统实质上是短时间内超高并发的业务场景，几分钟甚至几秒钟大量连接冲进服务器。考验的是服务器程序的负载能力（其中硬件，软件都要硬），硬件一般都是指分布式增加节点数量，软件则是接下来要讨论的重点。

首先我们要知道后台的程序是分层级的，尤其是流量大的业务基本上都是采用分布式架构搭建服务，首先连接进来要经过负载均衡分配到其中一个业务处理节点中，然后到展示层，到服务层最后到数据层。一般还会有缓存层，用来拦截流量。

层次鲜明可以方便编码，也方便拓展。秒杀系统设计的总思路一般都是 ： **尽量将流量拦截在上层，尽量别让连接访问数据库。** 秒杀系统之所以容易挂，很多时候都是大量连接压到了数据库，而数据库访问磁盘的I/O操作比内存慢多了，导致连接积压 数据读写锁冲突严重，并发响应速度慢，最终系统负载不够挂掉。

结合具体例子分析：12306春节抢票业务，假设一趟火车只有1000张票却有1百万人来抢，这些人在很短时间内同时抢票，服务器负载自然上去了。对比来看 1000000中只有1000人能成功，成功率只有千分之一，效率基本为0。仔细分析就会发现，在购买票之前肯定会检查还有没有票，这1000000个请求中大部分都会在这个检查阶段就out了，而这个检查操作如果是去数据库中查看票数，那么和没有拦截流量一致，导致所有流量都往数据库上奔。

其实这是一个典型的 **读多写少** 的业务场景，只写1000次 读却要读1000000次，这种场景是非常适合使用缓存的。

再结合具体业务看，当用户等待几秒后产生不耐烦就会不自觉的继续点击购票，这其实并不会增加用户的购票成功率，却会增大服务器的负载（不夸张的说 超过80%的请求都是重复点击造成的），所以一般会结合前端技术 **使购票按钮在点击后一段时间内不能再点击，或者后端限制同一ip一段时间内的连接数**，做这一个限制，已经算是一个小优化了。

对于服务器来说，1000张票只是一个具体的数字，只能提供1000个请求。所以同一时间让1w个请求到数据库是没有意义的，对于**写请求**可以来个**请求队列**，每次让一部分请求到数据库或者缓存中进行操作，一批批的操作直到没有票为止。而对于读请求则可以使用redis缓存来做，单机每秒10w请求都是ok的。

这样一来只有很少的请求会通过redis缓存层到数据库中，完成整个秒杀的过程。

当然还有其他手段进行优化：**请求数太多了，可以随机丢弃一些请求来降低负载**。因为用户对于秒杀活动本来就是有失败的心理准备，并不会影响用户体验。

以上主要来自 [秒杀系统架构优化思路](https://link.zhihu.com/?target=http%3A//click.aliyun.com/m/10737/)

**上面都是对秒杀系统的感性认识，接下来可以结合代码进行深入阐述**

从比较细的角度看，秒杀就是并发的一种。多个线程争抢一个资源，而良好的秒杀系统设计就是能控制线程对资源的争抢，既保证高并发又保证结果正确。

从代码的层面看秒杀，其实就是在某个方法中将商品的数量减1。在不考虑缓存的情况下，最简单的实现就是将这个方法用`synchronized`锁住，串行化的解决问题。稍微优化一点就是只锁住写数据库的部分代码，而将所有请求加入一个队列，也可以完成串行化的操作。

只是这样，没有并发，响应时间太长用户体验极差。**还是上面的场景我们仔细想想，用户往往是对其中1张票进行争抢，而不是对1000张票争抢，锁的粒度可以具体到1张票(1张票1个记录)**，从而大大减小争抢概率 毕竟1000000人抢一个资源(1000张票绑定为1个资源)和1000人抢1个资源可不是一个概念。

只需要为每张票设置一个互斥锁，以票的ID作为关键字，就不会导致所有线程互斥而是其中一部分互斥。而分布式锁正好可以解决这个问题

##### 分布式锁

分布式锁用于控制分布式系统之间同步访问共享资源的一种方式。毕竟在不同机器上共享资源，往往需要互斥锁来防止彼此干扰来保证一致性。

1000000个线程来秒杀1000张票，假设每张票都是1000个线程在竞争。将这1000张票的ID作为key放到redis中 ，key-value存储模式让redis成为实现分布式锁的重要工具。

java可以通过Jedis API来操作redis，基本上简单的系统里只需要 `set key value` `expire key seconds` 设置缓存过期时间  `del key`这三个接口

- 加锁 ：即把该票的ID 作为key，value随便来个值 放入 redis中
- 释放锁：就把该ID从缓存中删除
- 若请求的ID已经上锁，轮询一段时间后 返回，
- 处理异常情况：一个票的ID已经上锁，由于某种原因没有完成操作(中断或者异常发生)，自然不会释放锁，而这时候可以通过 超时设定来 自动在redis中清除该ID。

这种方法主要是将资源的竞争强度降了几个等级来做的，结合上述拦截流量的思路我觉得就是一个很好的秒杀系统了。

























