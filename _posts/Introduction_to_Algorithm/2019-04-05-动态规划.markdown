时隔好久，又来更新算法的东西了，因为前几周都在搞一个项目，没有时间写算法的东西。可是不搞算法，不刷算法题连大公司的面试都进不去，往往是拿到笔试资格之后就GG，虽然我算法不是很好但是我的代码量是够的，所以相信我勤加修炼一定能够搞定笔试这一关。

---

不说了，这两天在知乎上看到一个关于动态规划的回答，感觉很不错，[关于动态规划](https://www.zhihu.com/question/23995189) 所以想着记个笔记，顺便在LeetCode上写两题练练。**我个人觉得校招笔试考动态规划已经是极限了，如果到树和图那里就变态了。** 还有一些复杂逻辑的东西，各种转化。。感觉时间根本不够



先说说我对动态规划的理解吧：原理其实很简单，将已经**计算过的子问题答案储存**起来防止重复计算消耗更多时间和资源，用存储空间换取高效的时间。

但是原理简单实现起来就不那么容易了，有个直观的数据就可以表明动态规划算法的难度：

<img src="./img/12.png">

LeetCode上的相关题目基本都有一定难度。

好了情况介绍完了，我们开始笔记时间吧：

例子1：现在有这些面额的RMB 1 、5、10、20、50、100 ,想要用尽可能少的钞票数凑出金额为 w 

思路分析：很自然的我们会想到贪心策略，先用大面额的纸币然后递推下去就能够得到正确答案。

但是当纸币的面额发生了变化，贪心算法可能就不能得到正确的答案了。比如面额如下：1、5、11那么当我们想要凑出15元时就会出错：

沿用贪心算法：15-11=4  4-1=3 3-1=2 2-1=1 1-1=0  需要5张钞票，而实际上只需要3张5元即可得到答案。

>  事实上很多时候我们都会做出与贪心算法一样的选择，毕竟谁又能看得那么长远呢？

很多时候暴力穷举才是我们立马能够反应过来的算法，一张一张的去试总能得到正确答案，可是这并不是我们需要的算法，至于为什么我想各位都清楚。

还是刚才的例子，w=15，如果我们先取一张11的接下来就是面对w=4的情况；同理先取5元面对的是w=10的情况；先取1元面对w=14，，，，一阵假设下来我们发现了问题具有相同的形式。即这样的问题可以分解成多个子问题解决，并且子问题直接相互影响。

很自然的我们做出假设：f(n)=凑出n需要的最少钞票数，**以数学的抽象来概括之前用语文表述的段落。** 而这里的纸币面额只有三种，所以通向n的道路也只有三条，分别为：

f(n-1)、f(n-5)、f(n-11)  然后每一种情况都会面临和n一样的选择，这是一个递归的过程。我们要的答案更加抽象的来说是这样的：**f(n)=min{f(n-1)、f(n-5)、f(n-11)}+1**  加1是因为无论f(n-1) f(n-5) f(n-11) 选择1张纸币之后都可以达到f(n)

代码如下：很巧妙，在计算的同时顺便把边界也考虑了进去，

```java
for(int i=1;i<=n;i++){
    if(i-1>=0) cost=Math.min(cost,f[i-1]+1);
    if(i-5>=0) cost=Math.min(cost,f[i-5]+1);
    if(i-11>=0) cost=Math.min(cost,f[i-11]+1);
    f[i]=cost;
}
//f[15] 就是我们题目的要求了
```

f(n)只与f(n-1) f(n-5) f(n-11)相关，并不会和其他的逻辑混在一起。这种要解出f(n) 只需要知道几个更小的解，这种过程叫做求解f(n)的子问题，就是DP(Dynamic Plan) 动态规划。

>  实际的例子讲完了，大家会觉得DP也就这样嘛，没什么难的。(如果我是刚接触的话也会这么认为)，那就来看看理论性的东西吧，和数学一致我们做题的时候往往多刷几遍就知道怎么做了。但是要我们往数学的理论上面思考的话，我觉得没几个人能学进去(好吧其实是我自己学不进去）。

就在几个小时之后，我遇到了类似的题目：

小明去附近的水果店买橙子，水果商贩只提供整袋购买，有每袋6个和每袋8个的包装（包装不可拆分）。可是小明只想购买恰好n个橙子，并且尽量少的袋数方便携带。如果不能购买恰好n个橙子，小明将不会购买。请根据此实现一个程序，要求：
 输入一个整数n，表示小明想要购买n（1≤n≤100）个橙子
 输出一个整数表示最少需要购买的袋数，如果不能买恰好n个橙子则输出-1
 例如，输入20，输出3。  

按照上一题的思路是这样的：

```java
for(int i=1;i<=n;i++){
    int cost=Interger.MAX_VALUE;
    if(i-6>=0) cost=Math.min(cost,f[i-1]+1);
    if(i-8>=0) cost=Math.min(cost,f[i-5]+1);
    f[i]=cost;
}
```

结果并不如人意：

<img src="./img/14.png">

根本得不到正确答案，因为这里没有考虑到不能到达的情况，比如7个橙子的时候是不能买的，因为装了6个后剩下的1个是不够装的。**而例题中因为有一个面额是1的情况，所以是必达的。假设不是1元而是2元的面额，该程序依旧会出错。** 所以在考虑这类问题的时候，**重点在考虑是否具有最优子结构，因为很可能会出现无解的情况**



##### 概念来袭

1.**无后效性**：即子问题是如何计算的对后面的过程没有影响，只需要知道结果就可以。**书面的定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。**

2.**最优子结构**：比如我们之前的例题，”凑出**最少**张钞票“ 所以我们可以定义 凑出n所需要的**最少**张数为f(n) ，这就是最优的概念，而**大问题的最优解可以由小问题的最优解推出——就叫最优子结构**

所以基本上所有具有这些特性的问题都可以用DP来解决。



讲过理论之后再来个例子压压惊：要盗图了，还是开头给出的参考回答中的图

<img src="img/13.png">

好了，和刚才的例题类似：想要到达T就必须先打到C或者D，而想到C就必须先到A，，，类推下去选择其中费用最低的即可：用数学抽象出来刚才的描述是这样的、**f(T)=min{f(C)+20、f(D)+10}**

细心的朋友会发现，这两个例题的样子非常类似。而且得到的公式基本一模一样

f(P)=min{f(R)+w}  w为从R到P的消耗



DP的流水线操作：

1. 将大问题化为小问题
2. 求解小问题
3. 推出大问题的解

##### 重点来了：看到一个问题我们如何设计DP算法呢？毕竟不是所有问题都能够很快得知公式的，

1. 首先我们把面对的情况表示为**x**，这一步称之为 **设计状态**  如例题1中我们把要凑出的金额抽象成了n
2. 对于状态**x**、记我们要求的答案为f(x) 
3. 第三步：找出f(x)与哪些情况相关 记为 (**p**) 即如何能够达到f(x), 写出状态转移方程  就是这种形式(f(T)=min{f(C)+20、f(D)+10}) 我们通过f(p) 来推出f(x)   



> 解析完毕之后，惊呼DP好简单。妈妈再也不用担心我的学习，，，，好吧上了大学之后她就没担心过。

例题3：最长上升子序列（LIS）问题：给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。

​	例如：1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。

按照我平时的解题思路是这样的：从第一个数开始假设它就是子序列中最小的数，然后一个遍历找到它的上升子序列，记录长度，然后从第二个数继续。。。重复上述过程，双重循环之后得到答案。

```java
int max=0;
int count=0;
for(int i=0;i<n;i++){
    int temp=a[i];
    for(int j=i+1;j<n;j++){
        if(a[j]>temp){ //如果大于前面的数 说明在上升
            count++;
            temp=a[j];  //然后门槛向上抬起，，思路到这里发现了不对劲，这样并不能解决问题
        }
    }
}
```

应该是先得到第一个数的最长上升子序列，然后第二个，第三个....去最长的那个为答案，按照我一开始的想法还不能解决问题。**感觉越想越复杂，先只想着找到第一个数的最长子序列吧**：好吧我想不到，我承认我有点菜，，，



那么按照DP的思路来呢：*我先自己想*

1.我们需要面对的情况是找出**长度为n的数组中的最长上升子序列**

2.**f(n)**   表示在第n位置它的最长上升子序列长度

3.找出与**f(n)**相关的情况，好吧这里的关系好难找感觉前面的每一个都和它有关 f(n)=max{f(n-1),f(n-2)...}???  (ps: **我忽略了可以是一个循环，并不是一定要能够分个拎出来**)



**文章上的思路：**

**记 f(x) 为 以ax结尾的LIS长度(其实就是第x位置)， 答案就是  max{f(x)}**  好像很暴力 和我想的差不多，但是我想的情况更加复杂。。。

考虑比x小的每一个p：如果ax>ap 那么f(x)=f(p)+1 。最终数学表达式如下：

**f(x)= max{f(p)}+1**  **p<x , ap<ax**    所有f(p)中最大的+1，所以是个循环



>  其实动态规划难的原因在这里我可能体会到了，他并不是考察编程能力而是考察数学能力，所以才让众多cs的同学们难受。

```java
for(int i=0;i<n;i++){
    for(int j=0;j<i;j++){ //一个循环就得到了 f[i]的值
        if(a[i]>a[j]){ 
            f[i]=Math.max(f[i],f[j]+1); //这个代码思路比较曲折，难读
        }
    }
}
//f[n-1] 即为所求
// 个人觉得下面这段代码更容易懂
for(int i=0;i<n;i++){
    int max=f[0];
    for(int j=0;j<i;j++){ 
        if(a[i]>a[j]){ //在所有 a[i] > a[j]的情况下，得到最大的f[j]
            if(max<f[j]){
                max=f[j];
            }
        }
    }
    f[i]=max+1;
}
```



习题：1. 采用优化手段，将LIS以O(nlogn)的时间v复杂度解决。  *ps: 在我的印象中只有分治法可能是这个时间复杂度*

习题：2. 按顺序递推”和“记忆化搜索”是实现DP的两种方式。请查阅资料，简单描述“记忆化搜索”是什么。并采用记忆化搜索写出钞票问题的代码，然后完成[P1541 乌龟棋 - 洛谷](https://link.zhihu.com/?target=https%3A//www.luogu.org/problemnew/show/P1541) 。

习题：3. 01背包问题是一种常见的DP模型。请完成[P1048 采药 - 洛谷](https://link.zhihu.com/?target=https%3A//www.luogu.org/problemnew/show/P1048)。









