虽然短短20分钟，但是问了很多方面的问题，有的答上来了，有的没听过，有的不深入。。。总之感觉凉了。但是给我的启发还是大的，并没有问什么框架的东西，首先问了我对jdk中的哪个包比较熟悉(IO，网络包，集合类等)，然后就四处出击，*感觉根本没看我的简历*。直接问我JVM，堆的具体划分，GC算法，线程池，数据库，MySQL多个表join查询时的索引，聚簇索引，还有隔离级别等等，下面将对面试过程中的问题进行分析。

---

##### 1.hashmap的数据结构，扩容的情况

​	它的结构和HashSet是一致的，都是散列表。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/13.png?raw=true">

​	扩容策略和HashSet也是一样的，当散列表中的位置被占据超过75%(加载因子默认是0.75，用于扩容的因子)，就会扩容，过程如下：创建一个新的HashMap容量是原来的两倍，将原来的hashmap中的元素复制过去。

##### 2.ConcurrentHashMap与hashtable的区别(二者都是线程同步)

[从ConcurrentHashMap的演进看java多线程核心技术](http://www.jasongj.com/java/concurrenthashmap/) 看到这篇文章的时候，我不禁感慨我距离大神的距离好遥远啊。

​	Hashtable是对整个对象加锁，当Hashtable的大小增加到一定的时候，性能急剧下降，因为迭代时需要被锁定很长时间。

​	**jdk1.7**的时候ConcurrentHashMap引入Segment，，把一个大的HashMap拆分成N个小的HashMap

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/14.png?raw=true">

**寻址方式**：在读写某个Key时，先取该Key的hash值，并将该哈希值的高N位对Segment个数取模从而得到Key应该属于哪个Segment，接着如同操作HashMap一样操作这个Segment。

**同步方式**：Segment继承了[ReentrantLock](https://blog.csdn.net/lipeng_bigdata/article/details/52154637)，很方便对每个Segment上锁。

**对于读操作**，获取Key所在的Segment时，需要保证可见性(Valotile：只能修饰变量，可以将被其修饰的变量声明CPU缓存中的值无效，只能到主存中去找，保证该变量更改时可以被其他线程知道)

**对于写操作**，并不要求同时获取所有Segment的锁，如果那样就相当于锁住了整个Map。它会先获取Key-Value对所在的Segment的锁，获取成功之后就可以像操作一个普通HashMap一样操作该Segment，并保证Segment的安全性。

同时，由于其他Segment的锁并未被获取，因此理论上可以支持ConcurrencyLevel(等于Segment的个数)个线程安全的并发读写。

获取锁时，并不直接使用lock来获取，因为该方法获取锁失败时会挂起（参考[可重入锁](http://www.jasongj.com/java/multi_thread/#%E9%87%8D%E5%85%A5%E9%94%81)），它使用了自旋锁，如果tryLock获取锁失败，说明锁被其他线程占用，此时通过循环再次以tryLock的方式申请锁。如果在循环过程中该Key所对应的链表头被修改，则重置retry次数。如果retry次数超过一定值，则使用lock方法申请锁。这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗CPU资源比较多，因此在自旋次数超过阈值时切换为互斥锁。

**size操作**：put，remove和get操作只需要关心一个Segment，而size操作需要**遍历所有的Segment才能算出整个Map的大小**。简单方案是先锁住整个Map，计算完之后再解锁(毕竟可能计算size的时候，有其他线程对它进行增加或删除)。但是如果锁住的话，其他线程无法对它进行操作，不利于并行。

为了更好支持并发操作，ConcurrentHashMap会在**不上锁的前提逐个Segment计算三次size**，如果某相邻两次计算获取的所有Segment的更新次数(每个Segment都与HashMap一样通过modCount跟踪自己的修改次数，Segment每修改一次其modCount+1)相等，说明两次计算过程中并无更新操作，则这两次计算出的总size相等，则直接作为最终结果返回。**如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size**



##### 基于JDK1.8 CAS(Compare and Swap)的ConcurrentHashMap

Java 7位实现并行访问，引入了Segment这一结构，实现了分段锁，理论上最大并发度与Segment个数相同。Java 8为了进一步提高并发性，摒弃了分段锁的方案，而是**直接使用一个大的数组**。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值(默认是8)时将链表(寻址时间复杂度为O(N))转为红黑树(寻址时间复杂度为O(log(N)))。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/15.png?raw=true">

**寻址方式**：Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模来确定Key在数组中的索引。因为引入了红黑树，所以即使哈希冲突比较严重，寻址效率也足够高，并没有在哈希值的计算上做过多的设计。只是将Key的hashCode值与其高16位作异或并保证最高位为0(保证结果为正整数)

```java
static final int HASH_BITS = 0x7fffffff
static final int spread(int h){
    return (h^(h>>>16))&HASH_BITS;
}
```

**同步方式**：

**对于put操作**，如果Key对应的数组元素为null，则通过[CAS操作](http://www.jasongj.com/java/thread_safe/#CAS%EF%BC%88compare-and-swap%EF%BC%89)将其设置为当前值。如果Key对应的数组元素(即链表表头或者树的根元素)不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果put操作使得当前链表长度超过一定阈值，则该链表转换为树，用以提高寻址效率。

**对于读操作**，由于数组被volatile关键字修饰，因此不用担心数组可见性的问题。同时每个元素是一个Node实例(Java 7中每个元素是HashEntry)，它的Key值和hash值都有final修饰，不可变更，无须关心他们被修改之后的可见性。

```java
static class Node<K,V> implements Map.Entry<K,V>{
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next;
}
```

对于Key对应的数组元素的可见性，有Unsafe.getObjectVolatile()保证

```java
static final <K,V> Node<K,V> tabAt(Node<K,V> []tab,int i){
    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);

}
```

**size操作：**put方法和remove方法都会通过addCount方法维护Map的size，size方法通过sumCount获取size



##### 3.线程的生命周期，sleep()和wait()的区别，java线程和操作系统的线程之间的区别

[Java中sleep()与wait()](https://blog.csdn.net/u012050154/article/details/50903326)

[Java与线程](https://www.imooc.com/article/257138) [java线程是用户级的吗](https://www.zhihu.com/question/23096638)

生命周期：new，Runnable，等待，计时等待，阻塞，终止

sleep()：是正在执行的线程主动让出CPU，并不释放资源，过了指定时间之后继续执行。**可以在任何地方使用**

wait()：让当前线程退出同步资源锁，以便其他正在等待该资源的线程能够获取，只有调用了notify()方法才能够让它恢复过来，去参与竞争同步资源锁。**只能在同步块或同步方法中使用**

##### 4.Hibernate的缓存

[Hibernate缓存机制](https://www.jianshu.com/p/4ebf4b3b8e96)

##### 5.JVM的结构划分

[JVM内存结构](https://www.cnblogs.com/ityouknow/p/5610232.html)

[JVM内存结构和Java内存模型](https://zhuanlan.zhihu.com/p/38348646)

##### 6.MySQL隔离级别，join查询时采用的索引，聚簇索引

[MySQL隔离级别](https://www.jianshu.com/p/4e3edbedb9a8)

[对聚簇索引和非聚簇索引的认识](https://blog.csdn.net/alexdamiao/article/details/51934917)

##### 7.线程池

[jdk1.8下的线程池](https://juejin.im/post/5bac78ce6fb9a05cee1ded19)

[Java中线程池，你真的会用吗？](https://www.hollischuang.com/archives/2888)

##### 8.GC算法

[JVM垃圾收集与GC算法](https://www.jianshu.com/p/43c1b262d36b)

[Java GC算法 垃圾收集器](http://www.importnew.com/23752.html)

##### 9.DB连接池

[数据库连接池的实现及原理](https://juejin.im/post/5af026a06fb9a07ac47ff282)

[数据库连接池技术详解](https://juejin.im/post/5b7944c6e51d4538c86cf195)

##### 10.堆排序算法掌握



##### 11.内存限制下，找出2GB文件中最大的100个数字和重复次数最多的100个字符串。

[经典面试问题: Top K 之 ---- 海量数据找出现次数最多或，不重复的。](https://juejin.im/post/5aa0ee9f518825557c010bc0)

