[Reactor与Proactor的概念](https://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html) 

[IO多路复用原理剖析](https://juejin.im/post/59f9c6d66fb9a0450e75713f)

Reactor和Proactor的其实是 **I/O多路复用模型**（下面介绍）。一般地，I/O多路复用机制都是依赖于一个事件分离器(Event Demultiplexer)，分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的read/write事件处理器（Event Handler）。

开发者预先注册需要处理的事件及其事件处理器(或回调函数)；事件分离器负责将请求传递给事件处理器。其实就是一个注册分发的过程。

两个与事件分离器有关的模式是Reactor与Proactor。Reactor模式采用同步IO，而Proactor采用异步IO（有关同步与异步的概念见 [java.IO详解](https://krystalics.github.io/2019/07/18/java.io%E8%AF%A6%E8%A7%A3/) ）。

在Reactor中，事件分离器等待负责文件描述符或socket为读写做准备，然后将IO就绪事件传递给对应的处理器，最后由处理器负责完成实际读写工作。处理器实际上就是一个线程，负责获取操作系统内核中的数据并进行处理。

 而Proactor中，处理器——或者兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统的内核线程完成，发起IO请求的时候 传递给操作系统的参数 包括用户定义的数据缓冲区的地址和数据大小，操作系统的内核线程才能将数据送到指定位置。

写入从socket读到的数据（其实就是从网卡中读到的），事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。类似于操作系统跟java进程说，数据已经搬到你指定的位置了，你可以进行下一步的操作了。这样一对比，P**roactor中处理器和Reactor的区别就是 Proactor中的处理器不用获取数据。** 

而异步操作因为涉及到了操作系统，所以每个操作系统实现异步的方式都不一样，这需要操作系统提供异步API才能够实现，像是Windows的IOCP，Linux的AIO等。



##### 上面涉及到了多路复用的概念，这里简单介绍一下。

I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（读写状态就绪），就能够通知程序进行相应的读写操作。系统调用： **select,poll,epoll**都是IO多路复用的机制，他们本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责读写，读写过程是阻塞的。











