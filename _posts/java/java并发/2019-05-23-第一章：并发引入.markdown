又又又荒废了一周，不过终于下定决心啃下《Java 并发编程实战》这本书了，加油！！！！

---

##### Introduction：并发简史

> 编写正确的程序很难，编写正确的并发程序则难上加难

**在早期，计算机不包含操作系统**(很难想象一个计算机没有OS会是怎么样的)，它们从头到尾只运行一个程序。专业术语叫做“裸机”，在这种环境中，程序的编写异常困难(比现在的IDE快速开发要难的多)。后来随着科技发展，计算机的性能越来越强，如果只为一个程序服务**资源利用率太低了**。而且分进程实现比在一个进程中实现所有任务要更容易些。慢慢的，操作系统横空出世。

操作系统的出现使得计算机能够同时运行多个程序，每个程序在一个叫做进程的地方单独运行。进程的出现实际上就是对CPU的并发，利用时间分片能够在一段时间内运行起多个程序。操作系统为进程分配了资源，包括：内存，文件句柄(关于句柄handle这个概念很多人听到会一脸懵逼：简单来说就是类似于**编号**，像是指针的指针)等。

而不同**进程**之间是如何进行**通信**的呢？——> **socket，信号处理器，共享内存，信号量以及文件等。**

也是随着时间的推移，安稳的生活让我们对应用的性能提出了更高的要求，一个进程中串行的完成程序虽然直观并且简单但是每次只能做一件事，让我们很不爽。就像很多人喜欢边吃饭边看电视，我们希望一个应用也能够同时做多件事情(对进程的并发就接着出现了，线程)。而我们学习的并发也就是关于线程的并发。

到现在，多核pc已经很普遍了，一个进程里有多个线程而这些线程可能在多个cpu中同时运行。大大提高资源利用率很效率。线程也被叫做轻量级进程(Light Weight Process,LWP)，在现有的线程机制下：即同一进程下的线程共享进程的内存空间。这也就意味着，一个变量可能同时在被读和写。熟悉并发的同学们都知道，如果想要并发程序按照我们的设想运行，这种**读写顺序不能确定的机制**(因为多个线程同时运行时，我们并不能确定哪个线程会先执行该操作)需要一种更细粒度的数据共享机制。比如当一个线程在读某个变量时，其他线程不能够写它(锁机制)等等。这也对我们开发人员提出了挑战：如何能够编写正确的并发程序。

由于现代的科技已经进入了成熟阶段，单个CPU的性能提升越来越困难(主要靠提高CPU的转速，时钟频率来提升性能)，为了适应市场对性能的需求，厂商转而投向多CPU的研发。道理很好理解，分布式系统的发展与多CPU模式如出一辙：利用成千上万台便宜的pc来运行一个应用，承担巨大的访问负载。分布式系统看上去和一个pc运行多个应用相反，但是对于资源的利用来说并不是相冲突的。

对于软件来说，如果某个程序包含了多种任务，如同时有：IO和网络请求，那么管理不同任务的切换将带来额外的开销。所以我们把它们剥离出去形成一个个线程，让每一个线程专门执行某一项任务。比如，服务器程序在接受来自多个客户端的socket请求时，如果为每个连接都分配其各自的线程并且使用同步I/O，那么性能将会大大提高而且开发难度也会大大降低。如果只有一个线程工作，当有数据还在文件中输入那么这个线程就陷入阻塞，对于其他请求的响应就会停止。而为了避免这个问题，单线程服务器必须使用非阻塞I/O，这种I/O的复杂性远高于同步I/O。java也有专门的类库（java.nio）

像Java中的某些框架就是并发的：Servlet内部就是多线程的，编写Servlet的开发人员并不需要了解同时又多少个请求需要处理，也不需要了解socket输入输出流是否被阻塞。我们调用Servlet的service方法来响应web请求时，就像是编写单线程程序一样就可以。



说了这么多线程的好处，事物的两面性自然不允许它只有好处咯，Java对线程的支持，它提供了相应的类库以及JVM大大简化了开发步骤，但是同时提高了开发人员的技术要求，并发在任何一个语言中都是高级领域。它会出现的问题可以被概括为3类问题：

1.**安全性问题**：这种情况就是上文中说的多个线程同时对某个变量进行操作，而他们的访问顺序并不可控。这将导致不可预料的结果。这种情况用**同步机制**来解决，如果没有同步，那么无论是编译器，硬件还是RunTime环境都可以随意安排操作的执行顺序，例如对寄存器或者处理器的变量进行缓存，而这些被缓存的变量对于其他线程来说是不可见的。

2.**活跃性问题**：安全性的含义是“永远不会发生糟糕的事情”，而活跃性则关注另一个目标。即“某件正确的事请最终会发生”。当某个操作无法继续执行下去时就会发生活跃性问题。在串行程序中，活跃性问题就是死循环，而多线程中这样的情况比较多：死锁，饥饿以及活锁。

3.**性能问题**：活跃性意味着事情终将发生，但是可能不够快，很多时候我们希望这件事尽早发生。性能问题包括多个方面，例如服务时间过长，响应不够灵敏，吞吐率低，资源消耗过高，可伸缩性低等。在多线程程序中，当线程调度器临时挂起活跃的线程并转而运行另一个线程时，频繁的上下文切换(Context Switch)，这种操作会带来极大的开销。保存和恢复执行上下文，丢失局部性，并且CPU时间将更多的花在线程调度上面而不是执行任务上。

很多时候，我们并没有显示的创建一个线程，但是框架中仍然会有线程创建，因此在这些线程中调用的代码必须同样是线程安全的，这需要开发者格外的小心，因为开发线程安全的类需要更加谨慎细致。当JVM启动时，垃圾收集器，终结操作等内部任务都会各自创建一个线程在后台运行，如果要使用这些线程，我们就必须熟悉并发和线程安全。下面给出一些并发的模块：

- Timer，使任务在稍后的时刻运行，一次或周期性运行
- Servlet和JSP：Servlet框架用于部署网页程序以及分发HTTP客户端请求。到达服务器的请求可能会通过一个过滤器链被分发到正确的Servlet或JSP中。每个Servlet都表示一个程序逻辑组件，在高吞吐率的网站中，多个客户端可能同时请求同一个Servlet的服务。在Servlet规范中，Servlet同样需要满足被多个线程同时调用，它必须是线程安全的。













