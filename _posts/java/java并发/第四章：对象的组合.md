本文参考《java 并发编程实战》

---

#### 对象组合

到目前为止，我们介绍的都是一些基础的程序和类。我们并不指望每一次内存访问都进行分析确保程序是线程安全的，而是希望能将现有的线程安全的类组合成规模更大的组件或程序。在组合过程中，可能会破坏某些类的线程安全。

##### 设计线程安全的类

通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。在设计线程安全类的过程中，需要包含以下三个元素：

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

确保类的线程安全，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。对象域变量的状态空间就是他们所有可能的取值。状态空间越小就越容易判断线程状态，所以final类型的域越多就越简单（不可变对象就是只有一个状态）

在很多类中都定义了一些不可变条件，用于判断状态时有效的还是无效的。**比如命中计数器的取值范围是0~2^31，如果出现负值就是无效状态。**由于不变性条件以及后验条件在状态及状态转换上施加了各种约束，所以需要额外的同步与封装。**如果变量的某些状态是无效的，那么就要对其进行封装(就像上文中的命中计数器)**，否则客户的操作可能使该状态无效。

**存在不变性约束的多个状态变量，当更新其中某个变量的状态时，必须根据约束一起更新其他变量状态以保持不变性约束。即这些相关变量必须在单个原子操作中进行读取或者更新。**如果不了解对象的不变性条件和后验条件，就不能确保线程安全性。要满足在状态变量的有效值或状态转换上各种约束条件，就必须借助原子性和封装性。

##### 依赖状态的操作：

在某些对象方法中还包含先验条件，例如不能再空队列中删除元素，即删除元素前，队列必须处于非空状态。如果在**某个操作中包含有基于状态的先验条件，那么这个操作称之为依赖状态的操作**。在单线程中，如果某个操作无法满足先验条件，只能失败：在并发环境中先验条件可能会由于其他线程的操作而变为真，所以在并发程序中要一直等待先验条件为真然后再执行该操作。

在Java中，等待某个条件为真的各种内置机制(包括等待和通知等机制)都与内置加锁机制紧密相关。要想实现某个等待先验条件为真时才执行的操作**，一种更简单的方法是通过现有库中的类(例如：阻塞队列BlockingQueue，信号量Semaphore)来实现依赖状态的行为**。

##### 状态的所有权

以某个对象为根节点构造一张对象图，那么对象的状态将是对象中所有对象包含的域的一个子集。我们在定义类的时候，只考虑到它拥有的数据，所有权(Ownership)在Java中没有得到充分体现。反而成为了类设计中的一个要素：如果分配并填充了一个HashMap对象，那么就相当于创建了多个对象。HashMap对象包含了Map.Entry对象以及内部对象，所以它的逻辑状态就是上述这些对象的状态空间。

在许多情况下，所有权和封装性是相互关联的。[**对象封装它拥有的状态，即对它封装的状态拥有所有权**]，状态变量的所有者将决定用何种加锁协议来维持变量状态的完整性。如果发布了某个可变对象的引用，就不载拥有独占的控制权，改为了共享控制权。对于**构造函数和方法中传进的对象，类通常不拥有这些对象的所有权**，**除非这些方法是被专门设计为转移传递进来的对象的所有权(**例如，同步容器封装器的工厂方法)

**容器类通常表型出一种所有权分离的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。**如`Servlet`框架中的`ServletContext`就是其中一个例子，`ServletContext`为`Servlet`提供了类似于Map形式的对象容器服务，在`ServletContext`中可以通过名称注册`setAtrribute()`或获取`getAtrribute()`应用程序对象。

由于`ServletContext`是线程安全的，所以调用`setAttribute() getAttribute()`时不需要我们加同步机制，**但是当使用`ServletContext`中的对象时，可能需要同步。因为这些对象时应用程序拥有的，Servlet容器只是替应用程序保管它们。**



##### 实例封闭

如果某**对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全的使用**。你可以确保该对象只能由单线程访问(线程封闭)，或者加锁。

封装简化了线程安全类的实现过程，它提供了一种**实例封闭**机制(Instance Confinement)，通常简称封闭。通过将封闭机制与合适的加锁策略结合起来，可以确保**以线程安全的方式来使用非线程安全的对象**。将数据封装在对象内部，可以将数据的访问限制在对象的方法中，从而更容易确保线程在访问数据时总能持有正确的锁。下面来个具体例子：

```java
@ThreadSafe
public class PersonSet{
    @GuardedBy("this")
    private final Set<Person> mySet=new HashSet<>();
    
    public synchronized void addPerson(Person p){
        mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p){
        return mySet.contains(p);
    }
}
```

在这个类中，即使Person是非线程安全的，也可以安全使用。这里就是使用了加锁和实例封闭策略。实例封闭是构建线程安全类的最简单方式。实例封闭还可以使得不同的状态变量可以由不同的锁来保护。在Java平台的类库中还有很多线程封闭的示例，例如**ArrayList和HashSet不是线程安全的，但是类库提供了包装器工厂方法(Collections.synchronizedList及其类似方法)，使得非线程安全的类可以在多线程环境中使用.**这些工厂方法通过装饰器(Decorator)模式将容器类封装在一个同步的包装器对象上。只要包装器对象拥有对底层容器对象的唯一引用，即对底层容器对象的访问必须通过包装器来进行。

封闭机制更易于构造线程安全类，因为当封闭 类的状态时，在分析类的线程安全性时就无需检查整个程序。

##### Java 监视器模式

什么叫监视器模式呢？？其实它仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。













































