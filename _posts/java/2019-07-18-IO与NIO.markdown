本文参考文章：

[深入分析Java I/O的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html) 

[深入分析Java中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/)

[NIO入门](https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#icomments)

[Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)

实习的工作涉及到了文件的IO，我对这块并不是太熟悉，虽然也不要求我了解这方面的东西。但实际上很久之前，我对NIO和网络以及其他一些比较有难度的包就比较感兴趣，困于没有需求。这次NIO是在周会上说要学，当做工作来做，在这里要强推一波[帆软](http://www.fanruan.com/company) （虽然没什么流量）

---

我们知道Java的IO操作在java.io包下，大致可以分为

- 基于字节：InputStream，OutputStream，
- 基于字符：Writer，Reader

而文章中还附加了两个

- 基于磁盘的：File
- 基于网络的：Socket

前面的划分是根据**传输数据的数据格式**，后面的划分是**根据传输数据的方式**。文章中总结了一句我觉得很经典

> I/O的核心问题要么是数据格式影响I/O操作，要么是传输方式影响I/O操作

关于InputStream和OutputStream的层次结构这里就不展示了，由于我之前也接触过IO还算是有点熟悉，也知道它们是可以相互组合使用来操作数据，这里给出文章中的一个例子：

```java
OutputStream out=new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream("fileName")));
```

了解IO的同学都知道，IO是基于流的——关于流，*我的认识是数据就像水一样流淌。这里有一点，水一样流淌，意味着数据传输是持续的，并不是一块一块的*。这些操作数据的类，就像是一个个水管，控制着水的流向和速度以及大小。

我们知道在磁盘中存储的是二进制，或者说是字节并没有字符这么一说，而Java的字符流传输就是对字节流的一种包装，所有的I/O都是操作的字节！包装成字符流只是为了让我们人类更好的使用和理解罢了。

上面提到了字符流是对字节流的包装，那么真正接触到磁盘，要存储数据的时候字符流传输的还是字节，那么从我们传进去字符再到磁盘中的字节，中间肯定经过了一层转换。字符到字节的转换时很耗费计算资源的，如果是中文的话就更是如此，甚至还可能引发乱码问题。

接下来我们岔开主线，讨论一下编码。提起编码，相信大家脑海中都会浮现ASCII，UTF-8之类的，也大概知道编码是为了让我们人类能够和机器交互。各个编码的区别第二篇文章里有详细的讲述我这里就不赘述了。

我们直接进入它的核心部分：Java I/O操作中的编码层（即字符和字节的转换层）直接盗图啦

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/1.png?raw=true">

Reader是I/O中读字符的父类，而InputStream是读字节的父类。将二者关联起来的就是图中的InputStreamReader（连名字都起得很有关联性）。它负责在I/O过程中处理读取字节到字符的转换，而具体的转换则通过StreamDecoder实现。因为读是从本地磁盘中读，读的只能是字节码。所以读这边的转换时从 字节到字符。

StreamDecoder解码过程必须由用户指定Charset编码格式（如UTF-8），将字节转为对应的编码的字符，如果没有指定字符集，它将默认使用本地环境中的默认字符集（中文环境中就是GBK啦）

同样的写的情况与读的类似。写字符的父类是Writer，写字节的父类是OutputStream。通过OutputStream转换字符和字节

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/2.png?raw=true">

因为写的可能是字符，而磁盘中的只能是字节。所以写过程中的转换时单向的字符到字节。一个例子如下：

```java
String file = "C:\\Users\\12857\\Desktop\\iotest.txt";
String charset="UTF-8";

//将字符转换成字节，写进磁盘
FileOutputStream outputStream=new FileOutputStream(file);
OutputStreamWriter writer=new OutputStreamWriter(outputStream,charset);
writer.write("这是要保存的中文字符。。。。。。。。。。。。。");
writer.close();

//读取字节 转成我们看得懂的字符
FileInputStream inputStream=new FileInputStream(file);
InputStreamReader reader=new InputStreamReader(inputStream,charset);
StringBuilder builder=new StringBuilder();
char[] buf=new char[64]; //一次读64个字符
while((reader.read(buf))!=-1){
    builder.append(buf);
}
reader.close();
System.out.println(builder.toString());
```

一般指定编码都是 UTF-8，用本地环境如果放到其他环境部署很可能出现乱码。

本地磁盘的数据传输过程已经了解了，接下来要看看Java web中涉及的编码了。网络中传输的数据都是以字节为单位的，所有**数据都必须能够被序列化为字节**，而Java中的数据被序列化必须继承Serializable接口——很常见的就是 SpringBoot中的entity模块中的table类，需要继承Serializable，因为很多时候需要传输它们。

用户从浏览器发起一个HTTP请求，需要编码的地方有：URL，Cookie，Parameter。服务器接收到HTTP请求后要解析HTTP协议，其中URI，Cookie和POST表单参数需要解码。服务器还需要读取数据库中的数据，本地文件或者网络中其他服务器的文件，这些数据都存在编码问题，当Servlet处理完所有请求的数据后，需要将这些数据再编码通过Socket发送到用户请求的浏览器中，经过浏览器界面后解析成文本数据。

了解了Web中需要编码的地方之后，可以顺便知道一下遇到乱码应该怎么处理：要知道乱码的核心都是 **char到byte或者byte到char转换中编码和解码的字符集不一致** 。但是由于一次操作可能经过多次编解码，很难查到是哪个环节出了问题

这里列举我在开发中遇到的问题：网站中涉及到数据库的数据，中文全都是问号，英文显示正常。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/3.png?raw=true">

后来查到数据库中的编码是 latin1，和后台以及前端的编码UTF-8并不一致。

好了讲了一大串编码问题之后(我这只是节选原文部分)，让我们回归IO。

上文中举了一个字符和字节相互转换读写文件的例子，但是我们回忆一下我们使用IO的各个类的时候有这么麻烦吗？下面一个例子：

```java
StringBuilder builder=new StringBuilder();
char[] buf=new char[1024];
File file = new File("C:\\Users\\12857\\Desktop\\iotest.txt");
FileReader f=new FileReader(file);
while(f.read(buf)>0){
    builder.append(buf);
}
System.out.println(builder.toString());
```

可以看到例子中并没有InputStreamReader的转换。实际上这是因为FileReader继承了它，通过StringDecoder解码成char。使用了默认字符集（我的本地的是GBK）

我们花了很大的篇幅在讲数据的编解码，还有一个关键的问题是数据的存储过程，**如何将数据持久化到物理磁盘呢？**

---

我们知道数据在磁盘中最小的单位是文件，上层应用程序只能通过文件来操作磁盘上的数据，所以文件也是操作系统和**磁盘驱动器**交互的最小单元。结合Java来看，很有意思的是Java中的File并不代表一个真实存在的文件对象，当我们`new File("C:\\Users\\12857\\Desktop\\iotest.txt")` 的时候它返回一个和这个路径相关联的虚拟对象，这可能是一个真实的文件也可能是一个目录。

为什么要将文件和目录都抽象成是File呢？特别来个Directory好像也很方便呀，这是因为大多数情况下，我们并不关心这个文件是否真的存在，就算没有也可以创建一个。我们真正关心的是该怎样对该文件进行操作。

只有真正要进行读取的时候我们才要检查该文件是不是真的在磁盘中存在。例如FileInputStream类是操作文件的接口，在创建它的时候会创建一个FileDescriptor对象（该对象是真正代表一个存在的文件对象的描述）。当我们在操作一个文件对象的时候，通过FileDescriptor对象获取真正操作的底层操作系统关联的文件描述，比如FileDescriptor.sync()（实际上是调用native的方法，通过C++操作）可以将操作系统缓存中的数据强制刷新到物理磁盘。

从磁盘中读取一段文本，图示如下：（手动画图，略显粗糙）

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/4.png?raw=true">

总结一下：当我们传入一个文件路径，将会根据这个路径创建一个File对象来标识这个文件，然后会根据这个File对象创建真正读取文件的操作对象，以及一个关联真实存在的磁盘文件的文件描述符FileDescriptor，通过这个对象可以直接控制该磁盘文件。读字符文本需要通过StreamDecoder将字节byte编码成char格式，读取过程是由操作系统决定的。

---

##### Java Socket的工作机制

看完了本地磁盘的工作原理，那么就要了解网络的工作机制了。其实Socket只是一个概念，并没有具体到一个实体，它是一种抽象：用来描述计算机之间完成通信的一种功能。它就像是两个城市之间的交通工具（但并没有具体到是火车还是高铁）。

Socket也有很多种（类比交通工具），大多数情况下我们用的都是基于TCP/IP的流套接字。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/5.png?raw=true">

学过计算机网络的同学们看这个图是不是很熟悉，它是TCP/IP网络模型的简单具象，只不过在上层应用和TCP之间加了Socket，由此可知两台主机之间的通信必须通过Socket来连接，就好像两个城市的交流必须要有交通工具一样。

我们知道网络中是通过ip获得远程主机的地址，tcp或udp获得主机上通信的端口，这样就可以通过一个**Socket实例唯一代表一个主机上一个应用程序的通信链路**

当客户端要与服务器通信，客户端首先要创建一个Socket实例，操作系统将为这个实例分配一个没有被使用的本机端口，并创建一个包含本机地址和服务器地址以及端口号的套接字数据结构。在创建Socket实例的构造函数正确返回之前，将要进行TCP三次握手协议，TCP握手协议完成之后，Socket实例将创建完成，否则抛出IOException。

与之对应的服务器将创建一个ServerSocket实例，只需要指定的端口号没有被占用，一般该实例都会创建成功。同时操作系统也会为ServerSocket实例创建一个底层数据结构，这个数据结构中包含指定监听的所有地址。之后调用accept()方法，进入阻塞状态，等待客户端的请求。

当有一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息，正是请求源地址和端口。这个新的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的Socket实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表。所以ServerSocket所关联的列表中每个数据结构都代表与一个客户端建立的TCP连接

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/6.png?raw=true">

上图是我根据文章描述，画的一幅图，不知道理解是否有误。

好了Socket实例已经创建了，我们的目的是通过Socket传输数据。接下来将描述

##### 数据传输

当连接已经建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，通过这两个对象来交换数据。同时我们也知道网络I/O都是以字节流传输的，当Socket对象创建时，操作系统将会为InputStream和OutputStream分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成的。

写入端将数据写到OutputStream对应的SendQ队列中，当队列满了，数据将发送到另一端InputStream的RecvQ队列中，如果这时RecvQ满了，那么OutputStream的write方法将会阻塞直到RecvQ队列有足够的空间容纳SendQ发送的数据。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/7.png?raw=true">

值的注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能发生阻塞，所以网络I/O与磁盘I/O在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能造成死锁。

也是由于IO的种种缺陷，才催生出了NIO乃至AIO

##### 所以进入正题了，花了很多篇幅打基础，终于接触到了任务的本质NIO

我们把之前会出现阻塞的I/O称之为Blocking-I/O ——简称BIO。一旦线程阻塞将会失去CPU的使用权，这再大规模访问量和有性能要求的情况下是不能接受的。虽然可以采用并发来保证不会对其他连接的响应终止，而且也采用线程池来尽量减少线程数，减小线程开销。

可是随着业务的发展，尤其是移动互联网的发展，一个大型的网站可能需要同时保证几百万的连接数，我们不可能在服务器中拥有如此多的资源，即使使用线程池。

##### 为什么要使用NIO？

NIO的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的native代码，NIO将最耗时的I/O操作（即填充和提取缓冲区）转移回操作系统，因而可以极大地提高速度。

文中伊始我们就说过I/O是流方式处理数据，而NIO和它最大的区别就是 **数据打包和传输的方式** 。**NIO以块方式处理数据**

面向流的I/O系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。缺点是，面向流的I/O通常非常慢

面向块的I/O系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块，所以它比流式的要更快，但是面向块的I/O比较复杂和难度。

NIO的核心：Buffer，Channel，几乎每个I/O操作都要使用它们。Channel是对原来I/O包中流的模拟，到任何目的地（或来自任何地方）的所有数据都必须通过一个Channel对象。而Buffer实质上是一个容器对象，发送给一个通道的所有对象都必须首先放在缓冲区；同样的从通道中读取的任何数据都要读到缓冲区中

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/8.png?raw=true">

Buffer是一个对象，包含一些要写入或者刚读出的数据，在NIO中加入Buffer对象，体现了与原I/O的一个重要区别。在面向流的I/O中，数据将直接写入或者读到Stream对象中。

在NIO库中，所有数据都是用缓冲区处理的。牢牢记住这一点，缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。缓冲区是指上是一个数组通常它是一个字节数组，也可能是其他数据类型的数组，

最常用的缓冲区类型是 ByteBuffer，一个ByteBuffer可以在其底层字节数组上进行get/set操作（即字节的获取和设置）事实上每一个基本类型都有一个对应的缓冲区

- ByteBuffer
- CharBuffer
- ...

每一个Buffer类都是Buffer接口的一个实例。除了ByteBuffer，其他Buffer操作完全一样，只是处理的数据类型不一样。因为大多数标准I/O都使用ByteBuffer，所以它具有所有共享缓冲区操作以及一些特有的操作。

如下面展示了 FloatBuffer的一个例子：

```java
public static void main(String args[]) throws Exception {
    FloatBuffer buffer = FloatBuffer.allocate(10);

    for (int i = 0; i < buffer.capacity(); ++i) {
        float f = (float) Math.sin((((float) i) / 10) * (2 * Math.PI));
        buffer.put(f);
    }

    buffer.flip();

    while (buffer.hasRemaining()) {
        float f = buffer.get();
        System.out.println(f);
    }
}
```

##### 说完了什么是Buffer，就轮到Channel了

Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比较，Channel就是流。从上面的图中可知与Channel打交道的是Buffer。与流不同的是Channel是双向的，而流是单向的（如InputStream，OutputStream），Channel可以用于读和写或者一边读一边写

练习1：从文件中读取一些数据，如果使用原来的I/O，我们需要创建一个FileInputStream并从它那里读取，而在NIO中；我们首先从FileInputStream中获取一个Channel对象，然后使用这个通道来读取数据。而在NIO系统中，任何时候执行一个读操作，都是从缓冲区中读取。所以步骤如下：

- 从FileInputStream中获取Channel对象
- 创建Buffer
- 将数据从Channel读到Buffer中

```java
public static void read() throws Exception {
    FileInputStream fin = new FileInputStream("C:\\Users\\12857\\Desktop\\iotest.txt");
    FileChannel channel = fin.getChannel();
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //创建一个1K大小的缓冲区
    channel.read(byteBuffer); //将数据从通道读到缓冲区中
  }

public static void write() throws Exception {
    FileOutputStream fout = new FileOutputStream("C:\\Users\\12857\\Desktop\\iotest.txt");
    FileChannel channel = fout.getChannel();
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    byte[] message = {'S', 'o', 'm', 'e', ' ', 'b', 'y', 't', 'e', 's'};
    for (int i = 0; i < message.length; i++) {
      byteBuffer.put(message[i]);
    }
    byteBuffer.flip();
    channel.write(byteBuffer);
  }
```

我们不需要告诉通道要读或者写多少数据到缓冲区中，每一个缓冲区都有一个复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。

读和写我们都已经介绍过了，那么边度边写是怎么回事呢？？

- 首先创建一个Buffer，然后从源文件中将数据读到这个缓冲区
- 然后将缓冲区写入目标文件
- 不断读写，直到源文件结束

```java
static public void main( String args[] ) throws Exception {
    
    String infile = "C:/users/12857/desktop/source.txt";
    String outfile = "C:/users/12857/desktop/dest.txt";

    FileInputStream fin = new FileInputStream( infile );
    FileOutputStream fout = new FileOutputStream( outfile );

    FileChannel fcin = fin.getChannel();
    FileChannel fcout = fout.getChannel();

    ByteBuffer buffer = ByteBuffer.allocate( 1024 );

    while (true) {
      buffer.clear(); //清除上一波缓存

      int r = fcin.read( buffer ); //读数据到缓存中，并获得文件指针位置

      if (r==-1) { //如果到了文件结尾
        break;
      }

      buffer.flip();  //让缓冲区可以将新读入的数据写入另一个通道，就像开闸了一样

      fcout.write( buffer );
    }
  }
```



##### 缓冲区内部细节：即Buffer的设计细节

NIO中两个重要的缓冲区组件：状态变量和访问方法（accessor）

状态变量是上文中提到的内部统计机制的关键。每一个读写的操作都会改变缓冲区的状态，通过记录这些变化，缓冲区就能够管理自己的资源。具体如何管理的见下面的细节

##### 状态变量

Buffer用三个属性表示缓冲区的状态

- position：跟踪已经写了多少数据，实际上就是数组的指针位置
- limit：从缓冲区写入通道，表示缓冲区还剩多少数据。没有开启缓冲区到通道的时候，limit=capacity，开始写出的时候limt=position。
- capacity：缓冲区的最大容量
- mark：是个备忘位置，使用mark()方法令 mark=position，当reset()的时候会设定position=mark，有些时候会用到。

状态管理如下图所示：从一个Channel通过Buffer到另一个Channel

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/java/img/9.png?raw=true">

##### 访问方法

到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如：可能需要将用户数据保存到磁盘。在这种情况下，必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。还有就是需要从磁盘读取用户数据，在这种情况下，需要将数据从通道读到缓冲区，然后检查缓冲区中的数据。

这些例子都需要访问Buffer中的数据。

##### get()方法

以ByteBuffer为例，它有四个get()方法

- byte get() 获取当前position位置的单个字节
- ByteBuffer get(byte dst[])  里面调用的是get(dst,0,dst.length)也就是下一个get()方法，
- ByteBuffer get(byte dst[],int offset,int length) 从offset开始读取length个字节到dst[]中并返回ByteBuffer对象，
- byte get(int index) 获得index位置的字节

文章中对于第二第三个get()解释并不清楚，所以在jdk中找了出来。

```java
 public ByteBuffer get(byte[] dst, int offset, int length) {
     checkBounds(offset, length, dst.length);
     //remaining()=limit - position; 实际上就是缓冲区中还有多少数据
     if (length > remaining())  
         throw new BufferUnderflowException();
     int end = offset + length;
     for (int i = offset; i < end; i++)
         dst[i] = get();
     return this; //this就是 调用get()方法的ByteBuffer对象
 }
```

##### put()方法

ByteBuffer有5个put()方法

- ByteBuffer put(byte b) 往position位置写入一个字节
- ByteBuffer put(byte src[]) 写入一个数组，put(src,0,src.length)
- ByteBuffer put(byte src[],int offset,int length) 从offset开始写入length个src[]中的数据
- ByteBuffer put(ByteBuffer src) 将其他ByteBuffer写入
- ByteBuffer put(int index,byte b) 在index位置写入一个字节

还有一些其他的方法可以访问它，比如

- getByte()  getByte(int index)      putByte() putByte(int index)
- getChar() getChar(int index)      putChar() putChar(int index)
- getShort() getShort(int index)    putShort() putShort(int index)
- ....

事实上都是一对，一个相对位置 position，一个绝对位置 index

##### 如何使用缓冲区呢？？？只要一个内部循环

```java
while(ture){
    buffer.clear(); //position = 0;  limit = capacity;
    int r=fcin.read(buffer);
    
    if(r==-1){
        break;
    }
    buffer.filp(); //设置 limit=position, position=0 
    fcout.write(buffer);
}
```

read()和write()调用得到了极大的简化，细节都由缓冲区内部解决了。

嗯经过漫长的篇幅，我们已经基本掌握了缓冲区日常工作所需要的大部分内容了。接下来是更加复杂的缓冲区分配，包装，分片。还会讨论一些NIO带给Java平台的一些新东西。如何创建不同类型的缓冲区达到不同的目的，如何保护数据不被修改——只读缓冲区，和直接映射到底层操作系统缓冲区的 直接缓冲区。还有最后的NIO中创建内存映射文件



##### 缓冲区分配和包装

我们看文中的代码可以看到，初始化ByteBuffer并不是new ByteBuffer，而是使用静态方法allocate()方法来分配缓冲区

```java
ByteBuffer buffer=ByteBuffer.allocate(1024);
```

allocate()方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中，还可以将现有的数组转为缓冲区

```java
byte array[]=new byte[1024];
ByteBuffer buffer=ByteBuffer.wrap(array);
```

使用wrap()方法将一个数组包装为缓冲区，必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或直接访问。稍微探究一下allocate和wrap方法的原理

```java
public static ByteBuffer allocate(int capacity) {
    if (capacity < 0)
        throw new IllegalArgumentException();
    return new HeapByteBuffer(capacity, capacity);
}

public static ByteBuffer wrap(byte[] array,int offset, int length){
    try {
        return new HeapByteBuffer(array, offset, length);
    } catch (IllegalArgumentException x) {
        throw new IndexOutOfBoundsException();
    }
}
```

我们看JDK中的源码，都是new HeapByteBuffer，而HeapByteBuffer中的构造方法是调用的super()父类的构造方法，它的父类是 ByteBuffer，而ByteBuffer的构造方法也是调用super()设置那些状态，

```java
ByteBuffer(int mark, int pos, int lim, int cap,byte[] hb, int offset){
    // package-private
    super(mark, pos, lim, cap); //初始化状态值
    this.hb = hb;  //这里的hb就是我们传进去的 byte数组
    this.offset = offset;
}

Buffer(int mark, int pos, int lim, int cap) {       // package-private
    if (cap < 0)
        throw new IllegalArgumentException("Negative capacity: " + cap);
    this.capacity = cap;
    limit(lim); //设置limit
    position(pos); //设置position
    if (mark >= 0) {
        if (mark > pos)
            throw new IllegalArgumentException("mark > position: ("
                                               + mark + " > " + pos + ")");
        this.mark = mark;
    }
}
```

##### 缓冲区分片

slice()方法根据现有缓冲区创建一种子缓冲区，也就是说创建一个新的缓冲区。新缓冲区与原缓冲区的一部分共享数据





























