集合类库知识

---

##### **1.队列(queue)**

可以在尾部添加元素，头部删除元素，并且可以查找队列中元素的个数。它最简形式可能是这样的：并没有涉及到队列是如何实现的》》

```java
public interface Queue<E>{
    void add(E element);
    E remove();
    int size();
}
```

可以通过1. **循环数组** 和 2. **链表** 两种方式实现 。在JDK1.8中 它继承了Collection类

```java
public interface Queue<E> extends Collection<E>{
    
}
```



##### **2.Collection接口**

在Java类库中，集合类的基本接口是Collection接口，在jdk中它继承了Iterable

```java
public interface Collection<E> extends Iterable<E> {
    
}
```

它里面有两个最基本的方法

```java
public interface Collection<E>{
    //向集合中添加元素，如果改变了集合就返回 true ，如果集合没有变化就返回 false
    //如果在添加元素的时候，集合中已经有了该元素，就会返回false
    boolean add(E element); 
    Iterator<E> iterator(); 
}
```



##### 3.Iterator接口与Iterable接口

```java
public interface Iterator<E>{
//通过反复调用next方法，可以逐个访问集合中的每个元素。到末尾会抛出 NoSuchElementException
    E next(); 
//所以需要 hasNext()方法来确认。
    boolean hasNext();
//Iterator的remove方法很不一样，它必须在next()方法之后使用，删除掉刚刚next()的元素。
//如果没有接着next()方法，直接使用remove()就抛出 IllegalStateException异常
    void remove(); 
//提供forEach，lambda表达式
    default void forEachRemaining(Consumer<? super E> action);
}
```

如果想要查看集合中的所有元素，就请求一个迭代器。并在`hasNext()`返回true时反复调用`next()`方法。

```java
Collection<String> c=...;
Iterator<String> iter=c.iterator();
while(iter.hasNext()){
    String element=iter.next();
    // ...
}

//简单来写，还可以有另一个for each写法
for(String element:c){
    //
}

// Iterator 本身也提供一个更加现代的方法 lambda表达式
iter.forEachRemaining(element->do something with element);
```

`for each` 循环可以与任何实现了`Iterable`接口的对象一起工作，而`Collection`刚好实现了`Iterable`接口。jdk实现入下：

```java
public interface Iterable<T> {
    
    Iterator<T> iterator();  
    
// 提供forEach方法
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }

    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```



**元素访问的顺序取决于集合类型**，对于ArrayList 进行迭代，迭代器将从索引0开始，每迭代1次，索引值加1。HashSet中的元素则按照某种随机的次序出现。



##### 4.泛型实用方法 与 AbstractCollection的诞生

Collection和Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。这里实用方法是指开发中经常会使用的方法，比如Collection中的部分方法

```java
int size();
boolean isEmpty();
boolean contains(Object obj);
boolean containsAll(Collection<?> c);
boolean equals(Object other);
boolean remove(Object obj);
void clear();
...
```

如果让每一个实现Collection接口都要提供如此之多的方法是做重复的工作，所以为了能够让实现者更容易地实现这个接口——Java类库提供了AbstractCollection , 它将很多实用方法实现了，而其他想要实现Collection接口的都可以直接`extends AbstractCollection` 。



##### 5.集合框架中的接口 结构图

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/11.png?raw=true">

集合中有两个基本接口，Collection和Map。两个体系的一些不同：

Collection中添加元素 是  add(E element) 。

不过由于Map是键值对，所以用 put(K key,V value)来添加元素  V get(K key)获取元素

注意游离于几个体系之外的是 RandomAccess  ，它的作用是测试某个集合是否支持高效的随机访问，就像数组一样可以用下标任意顺序访问元素。里面没有任何方法

```java
if(c instanceof RandomAccess){
    user random access algorithm
}else{
    
}
```



List接口就提供了可以随机访问的方法

```java
void add(int index,E element);
void remove(int index);
E get(int index);
E set(int index,E element);
```



坦率的讲集合框架中的访问设置的并不是很好。其中有两种有序集合 List(由数组支持，所以可以提供随机访问) 和 LinkedList 是链表有序，但是随机访问很慢，最好使用迭代器来访问。



##### 6.Set

基本等同于 Collection接口，但是它定义的行为更加严谨。

add()方法不允许增加重复元素，而且重新定义了equals()方法，认为两个集合只要包含同样的元素就认为是相同的，不要求顺序相同：与equals()匹配的是hashCode()方法要定义保证包含相同元素的两个集合会得到相同的散列码

























