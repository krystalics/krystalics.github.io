今天下午接近三点的时候接到面试电话。 很幸运在大概一周后收到了offer

---

面试官很客气，体验很好，5星好评，明年再来(哭丧脸)。先一问一答，然后再集中解释。

开头先问了synchronized和Lock的区别：然后说了下 synchronized基本就是Lock的内置版本

然后任意初始化一个对象，我们该怎么估计该对象的内存占用大小：这要看该对象它的实力域中包含的对象和数据情况，假如只包含了一个int变量，那大约就是32个字节，而如果包含其他对象，则是该对象的引用大小加上数据大小...

假如包含其他对象实例的空间也算到一起呢，怎么计算：就把它包含的对象大小加上它的大小。。。

**那么如何使用代码来计算该对象的大小，包含引用对象的大小：** 当时面试官问的时候我满脸都是迷茫，支支吾吾了好久，然后只能说不知道了。

换个方向，假设有**1千万个数字在一个文件内**(数字不重复，且都小于2千万，换行隔开)，怎么尽快又省内存的把他按照从小到大的转移到另一个文件内，执行的IO操作是多少次：脑子一片空白，回答了归并加上数据分段处理，至于IO多少次，我就呵呵了。。。 没事，回去查些资料就好了。

对Java这块还有比较熟悉的模块吗？比如网络安全方面：我对集合类和多线程比较熟悉。

集合类库中有多少是线程安全的类呢？：ConcurrentHashMap，Vector，SynchronizedList，，，，

ArrayList和LinkedList随机读取的时间复杂度：O(1) 和 O(n) 。

那么查找呢？假设要判断数据是否在ArrayList或者LinkedList中：ArrayList是数组存储的，可以在有序的时候采用二分查找，至于链表恐怕只能迭代，如果把数据进行预处理放到HashSet中就可以利用hash查找。

说到hash查找，它的逻辑是什么呢：简单来说就是利用hashCode算法对该对象给出一个整数值，然后对整个HashSet的大小取模出来的值，就是它的存储位置。如果发生冲突，就采用拉链法。

HashMap或者HashSet的key是不可以重复的，那它们是如何判断一个对象是否是重复的呢？：它们里面有一个equals方法，用于判断对象是否一致。可以先用equals判断然后再计算hashcode插入：

你这两个顺序反了吧，先equals的话比较慢吧。因为两个对象的hashcode如果不一样的话，那么它们两个肯定不是一个一样的对象，：哦哦，有道理，有道理。

简述一下乐观锁和悲观锁吧：悲观锁就是synchronized这样的，认为一个资源在一段时间内一定会发生冲突，所以就把资源独占——锁了起来：而乐观锁就是认为该资源在一段时间内不会发生冲突，不加锁去获取资源，如果发生冲突就重新来过

有什么常见的乐观锁吗？：CAS，CompareAndSwap()就是比较经典的乐观锁。

假设有10个线程，对象里面只有一个变量`int i`，分别对它进行i++，最后的结果是什么呢？：因为i++这个操作是分为三个步骤，获取i的值，修改i的值，写入i的值。所以它不是原子操作，即不是线程安全的。所以线程的执行顺序和交替次序未知，最后的结果是一个小于10的数。

知道volatile吗？：它表示的是内存可见性，假设上一个例子中的i变量加上了volatile，那么它在高速缓存和寄存器中的值是不可用的，每个线程想要访问i，只能从内存获取它的值。

怎么获取一个单例：可以把它的构造函数设为 `private Gouzao(){}`，然后`synchronized getInstance()`获取实例

怎么延迟获取对象：这里我蒙了一下，上面说的不就是延迟获取的方法吗，可能这里我们两个的理解或者没听清吧。除了上面那个方法，我没想出来怎么延迟获取对象，，他说：没关系，没接触过这方面一下子想不到很正常的。

---

先重点说解析一下面试中没有思路的问题：

如何使用代码得知对象大小(包含引用对象的内存空间)：

[聊聊JVM（三）两种计算Java对象大小的方法](https://blog.csdn.net/iter_zc/article/details/41822719) 

[聊聊高并发（四）Java对象的表示模型和运行时内存表示](https://blog.csdn.net/iter_zc/article/details/39959563) 

*这几天学校的事情很多，所以就没有来得及更新，今天(6.3)才在午睡后抽出空闲继续开始恶补。*

我们要计算Java对象的大小就首先要了解它在内存中的表示。其实也很简单，无非就是数组和对象实例存储在堆区，它们的引用在方法区。但是里面具体的细节我就不是知道的很清楚了。emm，言归正传，让我们正式的开始吧。

##### 基于HotSpot虚拟机对于Java对象的内存探讨：

Hotspot主要是C++写的，所以它定义的Java对象表示模型也是基于C++实现的。Java对象的表示模型是“OOP-Klass”二分模型：

- OOP，Ordinary Object Point，普通对象指针。通俗的说就是表示对象的实例信息(堆区)
- Klass，Java类的C++对等体，用来描述Java类的信息，包含了元数据和方法信息等(方法区)

一个对象就包括两个部分——数据和方法，分别对应OOP和Klass。JVM运行时加载一个Class时，会在JVM内部创建一个**instanceKlass**对象放在方法区，表示这个**类的运行时元数据**。创建这个Class类的Java对象时，则会在JVM内部创建一个**instanceOOP**放在堆，它的引用在JVM栈中，表示这个**Java对象**。

JVM基于栈来运行的，当一个线程调用一个对象的方法时，会在它的JVM栈的栈顶创建一个栈帧(Frame)的数据结构，这个数据结构是用来保存方法的局部变量，操作数栈，动态连接和方法返回值的。**通过参数传递的值和在方法中new出来的对象引用保持在局部变量表中**。

《Java核心技术·卷1》中有着重说明过：**Java的方法调用是值传递，不是引用传递。所有传递进方法的参数都相当于在局部变量表中拷贝了一份，实际计算中改变的是局部变量表里面的值，而不是外部的变量值。**

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/38.png?raw=true">

在**堆中创建的Java对象实际只包含数据信息**，又分为三个部分：

- 对象头，也叫Mark Word：主要存储对象运行时记录信息，比如hashcode，GC分代年龄，锁状态标志，偏向线程ID，偏向时间戳等。它的长度和JVM的字长一致，比如32位JVM的对象头就是32位。到这里，我们可以明显的看出来**。对象锁，就是设置了对象头的某些位，当其他线程看到这个对象的状态时加锁状态后，就等待释放锁。**
- 元数据指针，即类对象指针，指向方法区的instanceKlass实例。**当调用对象方法时，实际定位到了instanceKlass 对象的方法元数据，而instanceKlass还有很多其他元数据，比如：运行时常量池，字段等。**
- 实例数据

如果是**数组对象的话，还有一部分：数组长度**。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/39.png?raw=true">

普通对象按照64位的JVM来算：

- 对象头(_mark) : 8个字节
- Oop指针，如果是32G内存以下，默认开启对象指针压缩 4个字节
- 数据区
- Padding(内存对齐) 按照8的倍数对齐

数组对象：还要加上

- 数组长度：4个字节



搞清楚了对象在内存的基本布局后，来个实战

```java
private static class ObjectA{
    String str;  // 引用4个字节
    int i1; // 4
    byte b1; // 1
    byte b2; // 1
    int i2;	 // 4 
    ObjectB obj; //4
    byte b3;  // 1
}
```

按照之前的计算方法：没计算引用对象大小的size又称为Shallow Size

8(_mark)+4(oop指针)+4(str)+4(i1)+1(b1)+1(b2)+4(i2)+4(obj)+1(b3)=31 要补充到8的倍数所以padding=1所以总共的size=31+1=32。

实际上HotSpot创建的对象的字段会先按照给定顺序排列一下，默认的顺序如下：**从长到短排列，引用排到最后** long/double->int/float->short/char->byte/boolean->Reference

所以加法顺序实际是这样的： 

8(_mark)+4(oop指针)+4(i1)+4(i2)+1(b1)+1(b2)+1(b3)+padding(1)+4(str)+4(obj)=32

padding的位置很重要，32位/64位cpu读数据的时候是以4/8字节为单位，这里的数据是存放在一块连续的内存区域中，如下图：以64位cpu为例，一次读取8个字节

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/40.png?raw=true">

所以padding是在适当的时候补全该字节使得某个变量的存储不用跨越两次CPU读取，避免造成数据混乱失真(**这是我个人的理解，博客上没有解释的很清楚，我想也许是这样吧**)

如果要计算实际大小(包括引用对象的大小)可以通过**递归的方式去计算**（我想这就是当时面试官想让我回答的点吧，递归：关于递归我会另找时间看几篇文章了解一下），*(给一个计算的例子，但是代码就不写了，实在看不懂)*



[多路归并 外排序 大文件排序 海量数据处理](https://blog.csdn.net/longzuo/article/details/46409249)：看了下文章，发现我之前想到的分段归并总体思路是错误的，我是分段用归并排序，而这边是：

首先将1千万个数据分成n批，然后分别进行排序。

n组排好序之后输入到文件中形成n个文件，

再生成一个长度为n的数组分别指向n个文件的指针，分别顺序读取各个文件的数据 如 n1读取第一个文件的第1个元素，n2读取第二个文件的第一个元素...，然后选择其中最小的数字写入新文件。被选择的那个数的指针往文件下一位移动，

然后再读取各个指针下的数据，，如此反复直到所有文件读完。

这种算法常用于大文件排序，文件大小超出内存容量，可以每次读取内存容量的数据进行内存排序，然后进行归并。类似问题都是先将大数据分为小数据，分而治之，有需要的话再归并。

[面试官眼中的单例](https://juejin.im/post/5b50b0dd6fb9a04f932ff53f)

单例模式是23中GOF模式中最简单，也是最经常出现的一种模式(SpringBoot中的BeanFactory)。它属于创建型模式，提供了一种创建对象的方式，确保只有单个对象被创建。主要目的就是想在整个系统中只能出现一个该类的实例，即一个类只有一个对象。**节约内存资源和节省对象创建时间**。

- 像是频繁使用的对象，可以省略创建对象所花费的时间，如果对象很大那么单例模式在这里就是很重要的设计
- 不需要频繁的创建对象之后，GC的压力也小了。

但是单例模式往往需要考虑线程安全等并发问题，提升了问题的复杂度。下面提出几种：

##### 饿汉模式：

```java
public class Singleton{
    private static Singleton instance=new Singeton();
    private Singleton(){} //构造方法要是 private的
    public static Singleton getInstance(){
        return instance;
    }
}
```

这种模式比较简单。补充一下 instance 被初始化的时间

>Singleton类被加载的时候就会被初始化。
>
>JVM规范虽然没有强制约束在什么时候开始类加载过程，但是对于类的初始化，JVM规范严格规定了有且只有4种情况必须立即对类进行初始化

4种情况包括：1.new 2.getStatic 3.putStatic 4.invokeStatic 这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：

- 使用new关键字实例化对象
- 读取一个类的静态字段 （被final修饰，已在编译期把结果放在常量池的静态字段除外）
- 设置一个类的静态字段（被final修饰，已在编译期把结果放在常量池的静态字段除外）
- 调用一个类的静态方法



##### 双重检查DCL

```java
public class Singleton{
    private volatile static Singleton singleton;
    private Singleton (){}  
    
    public static Singleton getSingleton() {
        
   //虽然外围的 判断看起来没有什么用处，但是
   //这个判断 减小了锁的粒度，还保证了线程安全。
   //可以在singleton非null时进行并发，提高性能
    if (singleton == null) {  
//synchronized后面如果跟的是类，则线程在该类中所有操作不能进行，
//包括静态变量和静态方法，对于含有静态方法和静态变量的代码块的同步通常使用这种方式。
        // synchronized(this) 是对象锁，锁住本对象。
        // synchronized(obj) 是obj的对象锁
        synchronized (Singleton.class) { 
  //为什么外面已经判断过了，里面还需要判断一遍呢？？？
  //这是因为在并发过程中，A线程之前已经有B线程据了锁，B线程刚好处于创建该对象的第2步，第3步没有执行完所以 singleton仍然是null，所以A线程获得锁之后还需要进行一次判断，
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
}
```

这里的 volatile 是用来防止指令重排序的：**防止new Singleton时指令重排序导致其他线程获取到未初始化的对象。**因为`instance=new Singleton() `这个操作不是原子操作：它分为三个过程，

- 1、给instance分配内存
- 2、调用Singleton的构造函数来初始化成员变量
- 3、将instance对象指向分配的内存空间(执行完这一步 Instance就非null了)，

而在**JVM的即时编译器中存在指令重排的优化**，也就是说上面的执行顺序可能发生变化 变为1-3-2，3先执行完毕，2未执行之前有另一个线程过来，这时的instance已经是非null了，所以不用经过锁就可以返回一个instance ，自然就报错了。

所以需要volatile来防止指令重排



##### 讲完了重点问题，现在开始查缺补漏

##### 1.Lock和synchronized区别

之前从某个地方听到了一个笼统的区分：`synchronized`是对象内置的锁，而`Lock`就是在对象外的锁，是`java.util.concurrent`中的机制，和`synchronized`作用一致。

查缺补漏之下：

锁的种类有很多种，像是`synchronized`属于悲观锁和可重入锁，而Lock属于可中断锁。可中断锁就是**在等待资源释放的过程中，该线程可以中断这个操作**，不再等待资源释放而转去做其他的事情。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。

synchronized是java的关键字，比较熟悉了就不赘述了，直接进入使用环境：

1.修饰代码块，后面跟的是变量，所以是对变量加锁。

```java
public int synMethod(int m){
    synchronized(m){
        
    }
}
```

2.方法声明：其他线程想要调用该方法时只能排队等候

```java
public synchronized void synMethod(){
    
}
```

3.synchronized后面跟对象：获得对象锁，其他线程访问该对象的这部分代码时需要等待

```java
public void test(){
    synchronized(this){
        
    }
}
```

4.synchronized后面跟类：能够将类中所有的操作，包括静态变量和静态方法都锁住。对于含有静态方法和静态变量的同步一般采用这种方式

```java
public void test(){
    synchronized(Test.class){
        
    }
}
```

Lock是可中断锁，它的一些方法定义在JDK中如下：

- lock()：用来获取锁，如果锁被其他线程占用，处于等待状态。如果采用Lock，必须去主动释放锁，并且发生异常时，不会自动释放锁。因此使用Lock必须在try{}catch{}中进行，而且释放锁的操作要在finally{}中，以保证锁一定会被释放，防止死锁发生。
- lockInterruptibly()：通过这个方法获取锁时，如果线程正在等待获取锁，这个线程能够响应中断即中断该线程的等待状态
- tryLock()：用来表示 尝试获取锁 ，成功返回true；失败返回false。使用该方法的线程并不会处于等待状态，因为锁被占用了只需要返回false告知。
- tryLock(long , TimeUnit)：与tryLock类似，增加了等待时间，在等待时间内获取到锁就返回true，否则false
- unlock()：释放锁，一定要在 finally中释放。



于2019.06.05---13:00 结束。







