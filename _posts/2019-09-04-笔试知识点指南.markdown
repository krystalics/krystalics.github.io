#### 记录秋招中积累的零碎知识点：

哪种协议同时使用TCP和UDP？		 [DNS同时使用TCP和UDP？](https://blog.csdn.net/fly_yr/article/details/51374938)

**DNS**：DNS同时占用UDP和TCP端口53 是比较好知道的。但是它分别在什么情况下使用TCP和UDP呢？

我们知道TCP和UDP最大的区别在于TCP的消息传输是可靠的，而UDP是不可靠的。而且TCP因为握手动作等占用系统开销比较大，所以UDP速度会更快一些：比较适合于对可靠性要求不高的服务。

DNS有两种服务器，1.主DNS服务器 2.辅助DNS服务器。 主服务器会从自己的数据文件中读取该区的DNS数据信息，辅助则是从主服务器中通信读取并加载，这个过程叫区传送zone transfer 

还有一个点就是**UDP一次能够传输的最大数据量是512B**，当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送，通常传统的UDP报文不会大于512字节。

域名解析时就使用UDP协议，不用经过三次握手，DNS服务器负载更低，响应更快。而且事实上很多DNS服务器只支持UDP查询包。



##### Enum类型的使用

Java中的Enum其实就和普通的类没什么区别，它的特点是 默认继承了 java.lang.Enum，所以不能extends别的类了。

```java
public enum Type {
    //这里的SHORT，INT，LONG其实就是一个个Type的实例，enum也经常用来做单例的设计，后面的数字是他们的默认值
    SHORT(0), INT(1), LONG(2);
    int type;

    Type(int type) {
        this.type = type;
    }

    enum type2 {S, I, L}

    public static void main(String[] args) {
        System.out.println(Type.SHORT.type); //short.type = 0
        System.out.println(type2.S); //这里只是表示类型
    }
}
```



##### Linux中统计一段代码耗时

笔试题中碰到，随手记下来，虽然之后估计不会看。

clock_gettime()：精确到**纳秒** **库函数**

gettimeofday() ：精确到**微妙** **库函数**

time ：精确到秒

clock ：精确到毫秒



##### CPU分支预测

[深入理解CPU的分支预测 Branch Prediction 模型](https://zhuanlan.zhihu.com/p/22469702)

参考文章中先是给出了一个例子：用256的模数随机填充一个固定大小的大数组，然后对数组的一半元素求和。

```c++
for (int i = 0; i < 100000; ++i)
{
    // Primary loop
    for (int c = 0; c < arraySize; ++c)
    {
        if (data[c] >= 128)
            sum += data[c];
    }
}
```

得到结果是：排序后计算 和 没有排序计算 的效率比是3:1。为什么排序后的速度比排序之前更快呢？

上述程序中有个 if 判断语句，按照我们的想象中的逻辑无论数组排序与否，都是要经过这个判断的，不应该有速度上的差异。这个就涉及到CPU的分支预测

联想到现实中的火车遇到弯道，司机看到岔路会将火车开到正确的轨道上，假如有一次开错了方向火车想要回到正确的道路就会耗费大量的时间。现代的CPU也是这样的，CPU的运行速度非常的快

当CPU看到这条分支的时候会尝试预测结果（这个结果和之前的历史数据相关，假如之前几个数据都是 小于，那么CPU就会预测下一个数据也是小于）， 

要知道，现代编译器是非常复杂的，运行时有着非常长的pipelines， 减速和热启动将耗费巨量的时间。

那么，有没有好的办法可以节省这些状态切换的时间呢？你可以猜测分支的下一步走向！

- 如果猜错了，处理器要flush掉pipelines, 回滚到之前的分支，然后重新热启动，选择另一条路径。
- 如果猜对了，处理器不需要暂停，继续往下执行。

如果每次都猜错了，处理器将耗费大量时间在停止-回滚-热启动这一周期性过程里。如果侥幸每次都猜对了，那么处理器将从不暂停，一直运行至结束。

上述过程就是分支预测(branch prediction)。虽然在现实的道口铁轨切换中，可以通过一个小旗子作为信号来判断火车的走向，但是处理器却无法像火车那样去预知分支的走向--除非最后一次指令运行完毕。

**所以排序后的数组运行程序更快**。我们可以通过其他方式来避免分支预测，比如文章中给出的位运算，

```c++
|x| >> 31 = 0 # 非负数右移31为一定为0
~(|x| >> 31) = -1 # 0取反为-1

-|x| >> 31 = -1 # 负数右移31为一定为0xffff = -1
~(-|x| >> 31) = 0 # -1取反为0

-1 = 0xffff
-1 & x = x # 以-1为mask和任何数求与，值不变
```

所以分支语句可以转换为；

```c++
int t=(data[c]-128)>>31; //if data[c]>=128 t=0,~0=-1 & data[c]=data[c]
sum+=~t&data[c]; //if data[c]<128 t=-1 ~t=0  & data =0
```



##### 二分查找的left和right的取值

[二分查找有几种写法？它们的区别是什么？](https://www.zhihu.com/question/36132386)

[left,right)   左闭右开，



##### Windows内核进程

- 临界区：只能同步一个进程中的线程，不能跨进程同步。一般用来做单个进程内的代码块同步
- 内核事件：多用于线程间通信，可以跨进程同步
- 互斥量：可以跨进程同步，还可以用来保证程序只有一个实例运行(创建命名互斥量)，也可以用来做线程间的同步
- 信号量：允许同时访问，不过限制线程数量



##### UTF8编码

数字和字母占 1 个字节

多数汉字占3个字节，少数汉字4个字节。





















