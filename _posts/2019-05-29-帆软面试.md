今天下午接近三点的时候接到面试电话。

---

面试官很客气，体验很好，5星好评，明年再来(哭丧脸)。先一问一答，然后再集中解释。

开头先问了synchronized和Lock的区别：然后说了下 synchronized基本就是Lock的内置版本

然后任意初始化一个对象，我们该怎么估计该对象的内存占用大小：这要看该对象它的实力域中包含的对象和数据情况，假如只包含了一个int变量，那大约就是32个字节，而如果包含其他对象，则是该对象的引用大小加上数据大小...

假如包含其他对象实例的空间也算到一起呢，怎么计算：就把它包含的对象大小加上它的大小。。。

**那么如何使用代码来计算该对象的大小，包含引用对象的大小：** 当时面试官问的时候我满脸都是迷茫，支支吾吾了好久，然后只能说不知道了。

换个方向，假设有**1千万个数字在一个文件内**(数字不重复，且都小于2千万，换行隔开)，怎么尽快又省内存的把他按照从小到大的转移到另一个文件内，执行的IO操作是多少次：脑子一片空白，回答了归并加上数据分段处理，至于IO多少次，我就呵呵了。。。 没事，回去查些资料就好了。

对Java这块还有比较熟悉的模块吗？比如网络安全方面：我对集合类和多线程比较熟悉。

集合类库中有多少是线程安全的类呢？：ConcurrentHashMap，Vector，SynchronizedList，，，，

ArrayList和LinkedList随机读取的时间复杂度：O(1) 和 O(n) 。

那么查找呢？假设要判断数据是否在ArrayList或者LinkedList中：ArrayList是数组存储的，可以在有序的时候采用二分查找，至于链表恐怕只能迭代，如果把数据进行预处理放到HashSet中就可以利用hash查找。

说到hash查找，它的逻辑是什么呢：简单来说就是利用hashCode算法对该对象给出一个整数值，然后对整个HashSet的大小取模出来的值，就是它的存储位置。如果发生冲突，就采用拉链法。

HashMap或者HashSet的key是不可以重复的，那它们是如何判断一个对象是否是重复的呢？：它们里面有一个equals方法，用于判断对象是否一致。可以先用equals判断然后再计算hashcode插入：

你这两个顺序反了吧，先equals的话比较慢吧。因为两个对象的hashcode如果不一样的话，那么它们两个肯定不是一个一样的对象，：哦哦，有道理，有道理。

简述一下乐观锁和悲观锁吧：悲观锁就是synchronized这样的，认为一个资源在一段时间内一定会发生冲突，所以就把资源独占——锁了起来：而乐观锁就是认为该资源在一段时间内不会发生冲突，不加锁去获取资源，如果发生冲突就重新来过

有什么常见的乐观锁吗？：CAS，CompareAndSwap()就是比较经典的乐观锁。

假设有10个线程，对象里面只有一个变量`int i`，分别对它进行i++，最后的结果是什么呢？：因为i++这个操作是分为三个步骤，获取i的值，修改i的值，写入i的值。所以它不是原子操作，即不是线程安全的。所以线程的执行顺序和交替次序未知，最后的结果是一个小于10的数。

知道volatile吗？：它表示的是内存可见性，假设上一个例子中的i变量加上了volatile，那么它在高速缓存和寄存器中的值是不可用的，每个线程想要访问i，只能从内存获取它的值。

怎么获取一个单例：可以把它的构造函数设为 `private Gouzao(){}`，然后`synchronized getInstance()`获取实例

怎么延迟获取对象：这里我蒙了一下，上面说的不就是延迟获取的方法吗，可能这里我们两个的理解或者没听清吧。除了上面那个方法，我没想出来怎么延迟获取对象，，他说：没关系，没接触过这方面一下子想不到很正常的。

---

先重点说解析一下面试中没有思路的问题：

如何使用代码得知对象大小(包含引用对象的内存空间)：

[聊聊JVM（三）两种计算Java对象大小的方法](https://blog.csdn.net/iter_zc/article/details/41822719) 

[聊聊高并发（四）Java对象的表示模型和运行时内存表示](https://blog.csdn.net/iter_zc/article/details/39959563) 

*这几天学校的事情很多，所以就没有来得及更新，今天(6.3)才在午睡后抽出空闲继续开始恶补。*

我们要计算Java对象的大小就首先要了解它在内存中的表示。其实也很简单，无非就是数组和对象实例存储在堆区，它们的引用在方法区。但是里面具体的细节我就不是知道的很清楚了。emm，言归正传，让我们正式的开始吧。

##### 基于HotSpot虚拟机对于Java对象的内存探讨：

Hotspot主要是C++写的，所以它定义的Java对象表示模型也是基于C++实现的。Java对象的表示模型是“OOP-Klass”二分模型：

- OOP，Ordinary Object Point，普通对象指针。通俗的说就是表示对象的实例信息(堆区)
- Klass，Java类的C++对等体，用来描述Java类的信息，包含了元数据和方法信息等(方法区)

一个对象就包括两个部分——数据和方法，分别对应OOP和Klass。JVM运行时加载一个Class时，会在JVM内部创建一个**instanceKlass**对象放在方法区，表示这个**类的运行时元数据**。创建这个Class类的Java对象时，则会在JVM内部创建一个**instanceOOP**放在堆，它的引用在JVM栈中，表示这个**Java对象**。

JVM基于栈来运行的，当一个线程调用一个对象的方法时，会在它的JVM栈的栈顶创建一个栈帧(Frame)的数据结构，这个数据结构是用来保存方法的局部变量，操作数栈，动态连接和方法返回值的。**通过参数传递的值和在方法中new出来的对象引用保持在局部变量表中**。

《Java核心技术·卷1》中有着重说明过：**Java的方法调用是值传递，不是引用传递。所有传递进方法的参数都相当于在局部变量表中拷贝了一份，实际计算中改变的是局部变量表里面的值，而不是外部的变量值。**

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/38.png?raw=true">

在**堆中创建的Java对象实际只包含数据信息**，又分为三个部分：

- 对象头，也叫Mark Word：主要存储对象运行时记录信息，比如hashcode，GC分代年龄，锁状态标志，偏向线程ID，偏向时间戳等。它的长度和JVM的字长一致，比如32位JVM的对象头就是32位。到这里，我们可以明显的看出来**。对象锁，就是设置了对象头的某些位，当其他线程看到这个对象的状态时加锁状态后，就等待释放锁。**
- 元数据指针，即类对象指针，指向方法区的instanceKlass实例。**当调用对象方法时，实际定位到了instanceKlass 对象的方法元数据，而instanceKlass还有很多其他元数据，比如：运行时常量池，字段等。**
- 实例数据

如果是**数组对象的话，还有一部分：数组长度**。

<img src="https://github.com/krystalics/krystalics.github.io/blob/master/_posts/img/39.png?raw=true">

普通对象按照64位的JVM来算：

- 对象头(_mark) : 8个字节
- Oop指针，如果是32G内存以下，默认开启对象指针压缩 4个字节
- 数据区
- Padding(内存对齐) 按照8的倍数对齐

数组对象：还要加上

- 数组长度：4个字节





[多路归并 外排序 大文件排序 海量数据处理](https://blog.csdn.net/longzuo/article/details/46409249)：看了下文章，发现我之前想到的分段归并总体思路是正确的，但是我是分段用归并排序，而这边是：

首先将1千万个数据分成n批，然后分别进行排序。n组排好序之后输入到文件中形成n个文件，

再生成一个长度为n的数组分别指向n个文件的指针，分别顺序读取各个文件的数据 如 n1读取第一个文件的第1个元素，n2读取第二个文件的第一个元素...，然后选择其中最小的数字写入新文件。被选择的那个数的指针往文件下一位移动，

然后再读取各个指针下的数据，，如此反复直到所有文件读完。

[面试官眼中的单例](https://juejin.im/post/5b50b0dd6fb9a04f932ff53f)



