#### 算法导论第二章：Getting Started

---

从 插入排序开始：[代码在这->](https://github.com/krystalics/algorithm/blob/master/src/com/company/chapter2/Insertion_sort.java) 

具体的证明过程我就不太懂了，这里介绍一下它的特性：对于少量的排序它是一个有效的算法，将整个元素集**分为两部分，**第一部分是已经排好序的(默认升序排列)，另一个部分是散乱的。

分析：很明显**当第一部分只有一个元素时，它是有序的**。而我们的排序也从这里开始，按顺序从第二部分抽出一个元素**i**，让其与第一部分的最后一个元素**j**(最大的那个)比较，if j>i 那么就将j元素后移一位，到达i元素的位置，接着继续从第一部分的最后一个元素(原本j的前一个)与i的值比较，，，直至第一部分没有元素了那么i就是第一个，或者在中途有个元素比 i 的小，那么就将它插到那个元素的后面一位。

循环之下，直至第二部分没有元素。



##### 练习  ：代码都在上面那个入口

##### 2.1-2 重写程序，使其按照降序排列。

​	降序排列  只需要将 while中的 A[j]>key 换成A[j]<key 即可 

##### 2.1-3 考虑以下查找问题：

​	输入：n个数的一个序列A=[a1,a2,,,,an]和一个值 v

​	输出：下标i 使得 v=A[i] 或者 当v不在A中出现时，v=null 

​	写出线性查找的伪代码， 使用一个循环不变式来证明你的算法是正确的。(即确保循环不变式瞒住三条必要性质。)

**答案：** 其实这是很简单的遍历，关键在于是要用循环不变式证明算法正确性。于我个人而言，觉得不重要，就没写。



##### 2.1-4 考虑将两个n位二进制整数加起来的问题，分别存储在两个n元组A,B中，结果存储在(n+1)元组C中，给出伪代码

```java
for(int i=n-1;i>=0;i--){
    switch(A[i]+B[i]){
        case 0:C[i+1]+=0;break;
        case 1:C[i+1]+=1;break;
        case 2:C[i+1]+=0,C[i]+=1;break;  //有进位
    }
}
差不多就是这个思想，具体细节就不深究了。
```

